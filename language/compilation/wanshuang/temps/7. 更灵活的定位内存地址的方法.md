[TOC]

# and、or
- `and` 快速设0
- `or` 快速设1

# ASCII
ascii是一套通用编码方案或者说编码表

从键盘输入`a`，在屏幕显示`a`，过程是怎样的？
1. 按下`a`键，输入信息被传递给计算机
2. 计算机将其编码成ascii码`61h`保存在指定内存空间中
3. 文本编辑器从内存中取出编码`61h`，将其送到显卡的显存上
4. 工作在文本模式下的显卡，用`ascii`码解析显存内容，`61h`会被作为字符`a`处理
5. 显卡驱动显示器，将字符`a`的图像画到屏幕上

# 以字符形式给出数据
相关指令
- db
- dw

# 大小写转换
- `A` `41h` => 低 `or 00100000B` 1000001B
- `a` `61h` => 高 `and 11011111B` 1100001B 

# `[idata+bx]`
通常用于基于偏移`idata`的偏移`bx`，常用写法如下：
```
mov ax,[200+bx]
mov ax,200[bx]
mov ax,[bx].200
```

这种模式对于数组数据处理很方便，原因在于：
1. 数据段通常不只有一组数据，所以不能单纯的使用段偏移
2. 而数据数据通常是连续的同类型数据，所以地址相对连续，可以通过基准偏移快速获取

# si、di
`si`、`di`和`bx`一样可以作为内存地址中的变量使用，比如：
```
[bx]、[si]、[di]

[idata+bx]、
[idata+si]、
[idata+di]
```

为什么需要`si`、`di`？
1. 因为一个`bx`不够用，有时候一段代码可能存在多个数组
2. 可以和`bx`组合使用，更灵活的表示地址

- `[bx+si]`、`[bx+di]`，也可以写成`[bx][si]`这种形式
- `[bx+di+idata]`、`[bx+si+idata]`

# 寻址方式总结
- 【直接寻址】`[idata]` 常量直接定位
- 【寄存器间接寻址】`[bx]` 变量间接定位
- 【寄存器相对寻址】`[bx+idata]` 变量+常量，在一个基础偏移地址上再偏移
- 【基址变址寻址】`[bx+si]` 2变量
- 【相对基址变址寻址】`[bx+si+idata]` 2变量+常量

# 暂存数据
暂存数据应该使用栈！

原因：
1. 寄存器数量有限
2. 放到内存单元中难以管理【需要人为记住存放的单元地址】

# 指定尺寸
1. 有寄存器参与处理时，根据寄存器可明确数据尺寸
    - `ax` word数据
    - `al` byte数据
2. 通过`X ptr`明确数据尺寸
    - `mov word ptr ds:[0], 1`
    - `inc byte ptr [bx]`
3. 有些指令已经明确操作的数据尺寸
    - `push`、`pop`只能进行字操作