[TOC]

# `int`指令
`int n`，引发中断类型码为`n`的中断

过程：
1. 获取中断类型码n
2. 标志寄存器入栈 IF=0，TF=0
3. CS、IP入栈 
4. (IP)=(n\*4)，(CS)=(n\*4+2)

我们将中断处理程序简称为**中断例程**

# 使用`int`模拟实现`loop`功能
实现`loop`需要两个信息
1. 循环次数
2. 跳转地址

流程设计
1. 使用cx存储循环次数
2. 使用`es:[di]`指向标号地址
3. 执行标号代码
4. 循环次数减1
5. 如果`cx`不为0，则跳转到标号处执行，否则向下执行

中断例程如何获取标号的段地址和偏移地址？

```
assume cs:code

code segment
start:  mov ax,0b800h
        mov es,ax
        mov di,160*12
        mov bx,offset s - offset se

        mov cx,80
    s:  mov byte ptr es:[di],'!'
        add di,2
        int 7ch ;如果cx!=0，转移到s标号处

    se: nop
        mov ax,4c00h
        int 21h

code ends
end start
```

1. int 7ch 引发中断，获取中断类型码
2. 标志寄存器入栈，IF=0，TF=0
3. CS、IP入栈
   1. `s`标号的段地址就是此时的段地址，
   2. 而`se`标号偏移地址就是当前偏移地址的下一位
   3. 而在此之前我们使用bx存储了`se`和`s`的偏移地址，就是说通过`se`的偏移地址即可计算出`s`的偏移地址
4. `cx-1`
   1. 如果`cx==0`则结束中断例程，恢复寄存器数据，执行下一位指令，
   2. 如果`cx!=0`则跳转到对应标号地址，执行相应指令

7ch中断例程：
```
lp:     push bp     ;bp是需要使用的寄存器，先入栈，结束程序后恢复
        mov bp,sp   ;将sp地址放到bp上，原因是bp寄存器可以用于动态地址，而sp不行
        dec cx
        jcxz lpret
        add [bp+2],bx   ;[bp+2]得到的是入栈ip地址【即se偏移地址】，加上`bx`可以得到`s`的偏移地址

lpret:  pop bp  
        iret
```

# `BIOS`
`BIOS`主要提供以下几部分内容：
1. 硬件系统的检测和初始化程序
2. 外部中断和内部中断的中断例程
3. 用于对硬件设备进行IO操作的中断例程
4. 其他和硬件系统相关的中断例程

`BIOS`系统提供了很多内置的中断例程，所以程序员可以根据需要通过`int`调用内置的中断例程。

# `BIOS`中断例程的安装
1. CPU通电，初始化`(CS)=0ffffH`，`(IP)=0`，从`0ffff:0`开始执行代码
2. `0ffff:0`指令是跳转执行硬件系统的检测和初始化程序
3. 初始化程序会建立`BIOS`支持的中断向量表，将`BIOS`提供的中断例程的入口地址登记在向量表中
4. 硬件系统检测和初始化完成后，调用`int 19h`进行操作系统的引导，将计算机交由操作系统控制
5. 操作系统启动后，除其他工作外，会将其提供的中断例程装入内存，并建立相应的中断向量