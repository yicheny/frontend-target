[TOC]

# 位操作符

1. 位操作符使用整型的操作数
2. 位操作符将其整型操作数视作二进制位的集合，为每一位提供检验和设置的功能
3. 此外，位操作符还可以用于`bitset`类型的操作数，该类型具有这里所描述的整型操作数的行为

## 位操作符表

|         操作符         | 功能  |            用法            |
|:-------------------:|:----|:------------------------:|
|          ~          | 位求反 |            ~e            |
|         <<          | 左移  |         e1 << e2         |
|         >>          | 右移  |         e1 >> e2         |
|          &          | 位与  |         e1 & e2          |
|          ^          | 位异或 |         e1 ^ e2          |
| <code>&#124;</code> | 位或  | <code>a &#124; y;</code> |

## 使用`bitset`或整型
1. 假设现在一个班级有30名学生
2. 现在进行一次测试，测试结果只有及格或不及格两种
3. 我们使用一个二进制位记录一次测试及格或不及格

假设现在第27位学生及格了，使用`bitset`设置就是这样
```c++
std::bitset<30> bitset_quiz1;
bitset_quiz1.set(27);
```

使用整型进行记录：
```c++
//选择long是因为long是32位整型，可以保证记录30位学生的成绩
unsigned long int_quiz1 = 0;
```

使用`unsigned long`进行实现相对复杂
1. 将测验数据和1个整数做**位或**操作
2. 该整数只有1个指定位是1
3. 这里我们需要一个只有第27位为1的无符号长整数
4. 这种整数可以使用**左移**操作符和整数常量1生成。
```c++
int_quiz1 |= 1UL << 27;
```
这里做了3个操作：
1. `1UL << 27`生成第27位为`1`的二进制无符号整数
2. `|`操作符将`int_quiz1`和`1UL << 27`取或
3. 将取或结果赋值给`int_quiz1`

实际上相当于：
```c++
int_quiz1 = int_quiz1 | 1UL<<27;
```

