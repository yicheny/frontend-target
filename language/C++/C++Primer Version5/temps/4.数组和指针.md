[TOC]

# 数组
## 初始化
```c++
int iArr[10];//中括号内必须是常数字面量或常数对象
int iArr[] = {1,2,3};//字面量形式声明
char cArr[] = "hello world!";//字符可以特殊声明
```

## 数组长度
标准库无默认方法
```c++
//方式1
sizeof(iArr) / sizeof(iArr[0])
//方式2
std::end(iArr) - std::begin(iArr)
```

## 数组不需要直接复制和赋值
1. 数组不能用另一个数组初始化
2. 不能将一个数组赋值给另一个数组

```c++
int ia[] = {0,1,2};
int ia2[](ia);//非法
int ia3[3];
ia3 = ia;//非法
```

> 一些编译器允许将**数组赋值**作为**编译器扩展**,但是我们应该避免这种非标准写法

# 指针
1. 指针是指向某种类型对象的复合数据类型，它记录了对象地址。
2. 通过解引用操作符`*`可以得到所指对象的值

```c++
int v = 1;
int *s = &v;//*操作符表明s是指针变量
std::cout << s << std::endl; //s是内存地址
std::cout << *s << std::endl;//*s是对象的值
```

另一种声明指针的风格
```c++
int* s = &v;
```

## 指针和引用的区别
指针和引用都可以间接访问另一个值，但它们之间有两个重要区别：
1. 引用总是指向某个对象【定义引用必须初始化】
2. 赋值行为的差异：
   1. 给引用赋值修改的是该引用关联对象的值
   2. 给指针赋值是修改关联对象

## 指向指针的指针
1. 指针本身也是可用指针指向的内存对象
2. 指针占用内存空间存放地址值、
3. 因此，指针所在的的地址也可以被指针存放
```c++
int v = 1;
int *pv = &v;
int **ppv = &pv;
std::cout << ppv << std::endl;//存放*ppv的地址
std::cout << *ppv << std::endl;//存放**ppv的地址
std::cout << **ppv << std::endl;//1
```

## 数组名自动转换为第一个元素的指针
```c++
int va[] = {1,2,3,4};
std::cout << va << std::endl;//内存地址
std::cout << *va << std::endl;//1
```

## `const`指针
```c++
int i = 1;
//指向const对象的指针
const int *pi = &i;
//const指针
int *const cpi = &i;
```

## 指针和`typedef`
### `typedef`使用指针
```c++
typedef std::string *ss;
 std::string v = "hello";
 int iv = 10;
 const ss pv = &v;
 std::cout << pv << std::endl;
 std::cout << *pv << std::endl;
 ```

### 易错案例
```c++
typedef string *pstr;
//typedef 是起一个类型别名，比如typedef string ss;则可以使用ss表示string类型
const pstr cstr;
```
问题：变量`cstr`是什么类型？

- 【错误】是`*pstr`类型的**指针**，使用`const`进行修饰
- 【正确】是`*const pstr`类型的**指针**，

二问：`const pstr`指针所表示的真实类型是什么？

很多人都会认为是`const pstr *cstr`类型，分散来看就是：
1. `pstr *cstr`是指针类型
2. `const`修饰，表示该指针只能指向`const`对象。