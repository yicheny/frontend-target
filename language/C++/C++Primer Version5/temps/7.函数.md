[TOC]

# 参数

## 使用引用形参返回额外信息

实现一个`fine_val`函数，在一个整型`vector`对象中搜索指定的元素

1. 如果找到满足要求的元素，则返回指向该元素的迭代器
2. 否则返回一个迭代器，指向该`vector`对象的`end`操作返回的元素
3. 此外，如果该值出现不止一次，我们希望返回其出现的次数，此时返回的迭代器指向第一个找到的元素。

具体代码见`../codes/ch7/extra_params.cpp`

## 更灵活的指向`const`的引用

- 如果函数具有普通的非`const`引用形参，
- 则不能通过`const`对象进行调用
- 因为此时，函数可以修改传递进来的对象
- 这违背了实参的`const`特性

但是比较容易忽略的是，调用这种函数时：传递一个右值 或 具有需要转换的类型的对象 同样是不允许的。

```c++
int incr(int &val){
    return ++val;
}

int main() {
    short v1 =0;
    const int v2 = 42;
    int v3 = incr(v1);//错误，v1不是int类型
    v3 = incr(v2);//错误，v2是const类型
    v3 = incr(0);//错误，字面不是左值
    v3 = incr(v1 + v2);//错误，加法不会产生左值
    int v4 = incr(v3);//ok，v3是一个非const类型的int对象
    return 0;
}
```

问题的关键是：**非`const`引用形参只能与完全同类型的非`const`对象关联**

应该将不修改相应实参的形参定义为`const`引用，如果将这种形参定义为非`const`引用，则无必要的限制了该函数的使用。

定义一个在字符串中查找指定字符的函数：

```c++
string::size_type find_char(string &s,char c){
    string::size_type i = 0;
    while(i != s.size() && s[i] != c)
        ++i;
    return i;
}
```

调用：

```c++
find_char("hello world!",'o');
```

结果会报错。

这种写法将`string`类型的实参当作普通（非`const`）类型的引用，尽管函数没有没有修改值，但是这种写法会导致不能通过字符串字面量调用。

合理的写法是这么定义形参：`const string &s`

继续深入这个问题。

假设:

1. 程序本身没有`const`对象参与
2. 只使用`string`对象（而非字面量或产生string对象的表达式）

在以上假设成立的前提下，依旧可能出错。

```c++
//这里我觉得已经涉及到`const`对象了
bool is_sentence(const string &s){
return (find_char(s, '.') == s.size()-1);
}
```

推荐做法是将不需要修改的形参定义为`const`类型，普通形参有3大限制：

1. 不能使用`const`对象
2. 不能使用字面量
3. 不能使用产生右值的表达式

## 传递指向指针的引用

实现两个指针的交换

```c++
void ptr_swap(int *&v1, int *&v2){
    int *tmp = v2;
    v2 = v1;
    v1 = tmp;
}
```

注意这个形参`int *&v1`，要从右至从理解，

1. `&`表示它是 引用
2. `*`表示它是 指向引用的指针
3. `int`表示它是int类型的指针

进一步思考为什么要使用`&`，

1. 因为传递的参数是指针类型
2. 如果没有`&`，则`*v1`表示的实际的值
3. 如果没有`*`，直接使用`v1`，无法实现引用互换

## `vector`和其他容器类型的形参

1. 通常，函数不应该有`vector`和其他容器类型的形参
2. 调用含有普通的非引用`vector`形参的函数，会复制`vector`容器的每一个元素

从避免复制`vector`的角度出发，我们可能会考虑将形参声明为引用类型。

事实上，C++程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器：

```c++
void vec_print(vector<int>::const_iterator beg,
               vector<int>::const_iterator end)
{
    while(beg != end){
        cout << *beg++;
        if(beg != end) cout << " ";
    }
    cout << endl;
}
```

## 数组形参
数组有两个特殊的性质，影响我们在函数中的定义和使用
1. 不能复制数组
2. 使用数组名时，数组名会自动转换为指向其第一个元素的指针

- 因为数组不能复制，所以无法比那些使用数组形参的函数
- 因为数组会被自动转换为指针，所以处理数组 通常通过操纵 指向数组中的元素的指针来处理数组

### 问题
1. 最明显的一个问题就是：怎么获取数组长度？ 
2. 另一个蛋疼的问题是：我现在使用声明了数组`iArray`，但是我使用`iArray`它就是指针，那么我怎么通过名称获取到数组本身？

就目前来说，这两个问题的应对：
1. 并不需要通过程序自动获取，可以手动提供。因为定义数组时会提供长度，所以对于每个数组而言长度都是确定的
   1. 还是很恶心，因为支持`int a[]`这种动态写法，此时获取需要通过一些表达式计算，比如`sizeof(a) / sizeof(a[0])`，但是这个表达式不能抽象成函数使用，很难受。
2. 通过数组名+数组长度即可得到整个数组的值，通过这种方式间接获取


# 局部对象
## 静态局部对象
问题在于：静态局部对象如果不是在当前函数执行完成时销毁，它在什么时候被销毁？

# 内联函数
通过语言实现一个简单的需求：得到两个字符串中比较短的那一个
```c++
string s = s1.size() < s2.size() ? s1 : s2;
```

提炼成函数：
```c++
const string &shorterString(const string &s1,const string &s2){
    return s1.size() < s2.size() ? s1 : s2;
}
```

意义在于：
1. 通过函数名比阅读语句更容易理解意义
2. 如果要做任何修改，修改函数比寻找并修改每一处等价的语句容易
3. 保证统一的行为，使用相同的方式实现
4. 函数可以复用，不必为此重写代码

不过直接定义函数调用也有一些缺点：
1. 调用函数比求解等价表达式要慢，因为机器调用函数需要做很多工作：
   1. 调用前先保存寄存器，并在结束时恢复
   2. 复制实参
   3. 程序必须跳转到新地址执行

针对调用函数的这个缺点，`c++`提供了内联函数方案，即在原有函数前加上`inline`

那么函数不会以一般的方式编译，而是直接在编译时展开。

比如说我们这么调用：
```c++
cout << shorterString(s1,s2) << endl;
```

会被展开成：
```c++
count << (s1.size() ? s2.size() ? s1 : s2) << endl;
```

这样子执行效率不会降低，同时维护和可读性也更加友好。

不过，并不是任何函数都适合内联，一般推荐经常被调用的、代码量少的函数内联。

而递归函数、代码量极大的函数并不是适合内联展开，一则是编译效率很低，二则是打包后的体积会变大很多。

从编译角度考虑另外一点是，如果是普通函数进行修改，则编译可以只编译函数定义的部分，而不必重新编译调用的地方。如果是内联函数，则所有被调用的地方都需要重新编译。