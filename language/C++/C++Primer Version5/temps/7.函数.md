[TOC]

# 参数
## 使用引用形参返回额外信息
实现一个`fine_val`函数，在一个整型`vector`对象中搜索指定的元素
1. 如果找到满足要求的元素，则返回指向该元素的迭代器
2. 否则返回一个迭代器，指向该`vector`对象的`end`操作返回的元素
3. 此外，如果该值出现不止一次，我们希望返回其出现的次数，此时返回的迭代器指向第一个找到的元素。

具体代码见`../codes/ch7/extra_params.cpp`

## 更灵活的指向`const`的引用
- 如果函数具有普通的非`const`引用形参，
- 则不能通过`const`对象进行调用
- 因为此时，函数可以修改传递进来的对象
- 这违背了实参的`const`特性

但是比较容易忽略的是，调用这种函数时：传递一个右值 或 具有需要转换的类型的对象 同样是不允许的。

```c++
int incr(int &val){
    return ++val;
}

int main() {
    short v1 =0;
    const int v2 = 42;
    int v3 = incr(v1);//错误，v1不是int类型
    v3 = incr(v2);//错误，v2是const类型
    v3 = incr(0);//错误，字面不是左值
    v3 = incr(v1 + v2);//错误，加法不会产生左值
    int v4 = incr(v3);//ok，v3是一个非const类型的int对象
    return 0;
}
```

问题的关键是：**非`const`引用形参只能与完全同类型的非`const`对象关联**

应该将不修改相应实参的形参定义为`const`引用，如果将这种形参定义为非`const`引用，则无必要的限制了该函数的使用。

定义一个在字符串中查找指定字符的函数：
```c++
string::size_type find_char(string &s,char c){
    string::size_type i = 0;
    while(i != s.size() && s[i] != c)
        ++i;
    return i;
}
```

调用：
```c++
find_char("hello world!",'o');
```
结果会报错。

这种写法将`string`类型的实参当作普通（非`const`）类型的引用，尽管函数没有没有修改值，但是这种写法会导致不能通过字符串字面量调用。

合理的写法是这么定义形参：`const string &s`

继续深入这个问题。

假设:
1. 程序本身没有`const`对象参与
2. 只使用`string`对象（而非字面量或产生string对象的表达式）

在以上假设成立的前提下，依旧可能出错。
```c++
//这里我觉得已经涉及到`const`对象了
bool is_sentence(const string &s){
    return (find_char(s,'.') == s.size()-1);
}
```

推荐做法是将不需要修改的形参定义为`const`类型，普通形参有3大限制：
1. 不能使用`const`对象
2. 不能使用字面量
3. 不能使用产生右值的表达式

## 传递指向指针的引用
实现两个指针的交换
```c++
void ptr_swap(int *&v1, int *&v2){
    int *tmp = v2;
    v2 = v1;
    v1 = tmp;
}
```
注意这个形参`int *&v1`，要从右至从理解，
1. `&`表示它是 引用
2. `*`表示它是 指向引用的指针
3. `int`表示它是int类型的指针

进一步思考为什么要使用`&`，
1. 因为传递的参数是指针类型
2. 如果没有`&`，则`*v1`表示的实际的值
3. 如果没有`*`，直接使用`v1`，无法实现引用互换

## `vector`和其他容器类型的形参
1. 通常，函数不应该有`vector`和其他容器类型的形参
2. 调用含有普通的非引用`vector`形参的函数，会复制`vector`容器的每一个元素

