[TOC]

# 索引式文件系统
以windows的NTFS和Linux的EXT2为例，这两个都是索引式文件系统。

我们知道现代计算机中的文件除了数据，还有权限和很多属性设置。

所以除了划分数据区存储数据，还划分了一个索引区，存储文件属性、权限以及数据区索引，这个索取节点叫做`inode`，每个文件对应一个`inode`

除了`inode`和数据区块，还有一个区块叫做`super block`，这个区块用于记录整体信息，比如说数据去的总量、使用量、剩余量等

总结下，索引式文件系统一般包括三部分：
1. 超级区块
2. 索引区块
3. 数据区块

使用索引式文件在读取数据上有相对优势，比如说现在有一个`inode`记录了文件`a.txt`的信息，里面记录了`a.txt`的数据区位置是1、55、8、11，那么可以先排序为1、8、11、55，然后再进行查找，这样的话磁头只需要转动一圈就可以查找出所有数据。

而相对于老式文件系统，比如说FAT，这个文件系统只有数据区，和链表有些相似，每个数据区记录了下一个数据的位置，以上述为例，会以`1->55->8->11`的顺序进行查找，那么磁盘查询时会转动多圈，使得查询效率变低。

> FAT针对这类情况，可以使用“碎片整理”将零散的数据整合到一起，索引式文件没有这个问题，一般不用特殊处理

## `ext2`
刚刚介绍了索引式文件系统，实际上会有一个问题，就是如果我们将所有数据和inode都统一处理，对于一些大容量分区来说可能不是特别友好。

> 索引区和数据区的大小和数量在格式化后就固定了，除非重新格式化（或通过特殊指令），否则是不能更改的。

`ext2`文件系统最大的特点就是将统一处理改为了区块组处理。

`ext2`的文件系统组成是引导区+多个区块组。

每个区块组里面都有超级区块、索引区块、数据区块，相对于使用一个统一区块组，利用区块组进行分割可以更有效也更方便的管理数据。

每个区块组由6个部分组成：
1. `super block`
2. 文件系统描述
3. 区块对应表
4. `inode`对应表
5. `inode table`
6. `data block`

### `inode table`
简单介绍下`inode`记录的内容：
- 一般权限：rwx
- Owner
- Group
- 特殊权限
- 大小
- atime、ctime、mtime
- 文件真正指向
- ……

`ext2`中1个`inode`占用`128B`，`inode`记录一个数据区使用`4B`，对于数据区的记录，`inode`使用12个直接、1个间接、1个双间接、1个三间接记录。

> 注意，间接会使用一个数据区块进行记录，可记录数据区块位置量与其区块大小相关

以区块大小为1K的为例，1个区块可以记录`1024/4=256`条
(12 + 256 + 256*256 + 256*256*256) * 1K= 16GB

所以如果数据区块大小格式化为1K，则最大可记录单个文件大小为16GB

### `super block`
超级区块记录的信息主要有：
- 数据区块和索引区块的总量
- 未使用和已使用的 数据区块、索引区块 数量
- 数据区块大小（1、2、4K）
- 索引区块大小（128B、256B）
- 文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘的时间等
- 一个有效位数值，若为1则标识文件系统已被挂载，若为0则标识文件系统尚未挂载
- ……

### 文件系统描述（Filesystem Description）
描述每个区块开始与结束的区块，说明每个区段（超级区块、对照表、inode对照表、数据区块）分别介于哪一个区块之间，这部分可以使用`dumpe2fs`指令查看

### 区块对照表（block bitmap）
新增文件需要使用区块？系统会使用哪个区块来记录？比如选择空区块使用，如何知道哪个区块是空区块？这里就会使用区块对照表。

区块对照表可以快速查找出哪些区域是空的，系统就可以使用空区块进行使用

同样的，删除文件后，原本占用的区块号就会被释放出来，对照表中对应区块的标识就会变为“未使用中”

### inode对照表(inode bitmap)
和区块对照表类似，不过记录的是inode占用信息

## `dumpe2fs`
查询ext系列超级区块信息的命令

```shell
dumpe2fs [-bh] 设备文件名
```
- `-b` 列出保留为环道的部分（环道？）
- `-h` 仅列出超级区块的数据，不会列出其他的区段内容

# 目录树
介绍下文件系统关于文件的记录。

对于目录：
- 建立目录时，会分配1个inode和至少一个区块给该目录（区块用于记录该目录下的文件及文件对应的inode）

对于文件：
- 分配inode和至少一个区块，如果文件较大，除了数据区块，还会有一部分间接区块（用于记录区块号码）

文件系统必须被挂载到目录树上才能使用，挂载点必然是目录。

## 文件读取
关于目录树读取，我用一个示例说明下，加入我们想读取`/ect/passwd`的数据，它是怎么查找的呢？

首先看一下基本的目录挂载信息：
```shell
ll -di / /etc /ect/passwd
=> 64 dr-xr-xr-x.  18 root root  236 5月  18 12:47 /
=> 33574977 drwxr-xr-x. 144 root root 8192 5月  19 00:23 /etc
=> 34344917 -rw-r--r--.   1 root root 2301 5月   3 23:26 /etc/passwd
```

1. 通过挂载点信息找到`inode`号码为64的根目录的`inode`，且`inode`记录的权限让我们可以打开对应区块的内容（权限为r-x）
2. 在`/`数据区块内，查找到`/etc`目录的`inode`号码
3. 通过`inode`号码查找`/etc`的`inode`区块，记录的权限`rwx`让我们可以打开对应区块的内容
4. `/etc`数据区块内，记录了`/etc/passwd`的`inode`号码
5. 通过`inode`号码查找到`/ect/passwd`的`inode`区块，记录的权限`rw-`让我们可以打开对应区块的内容
6. 找到`/ect/passwd`的数据区块，获取其内容

## 文件新增
基本操作：
1. 确认用户对新增文件所在目录是否具有w和x权限，有的话才能新增
2. 根据inode对照表找出没有使用的inode号码，并将新增文件的权限和属性写入
3. 根据区块对照表找到没有使用的区块号码，将数据写入区块中，且更新inode区块指向数据区
4. 将刚刚写入的inode区块和数据区块信息同步到inode对照表、区块对照表、超级区块

通常，我们将inode区块和数据区块称为**数据存放区域**，将inode对照表、区块对照表、超级区块称为**元数据**——因为每次新增、删除、修改都会影响到这三部分的内容，这些部分的数据时经常变动的，所以被称为元数据

正常情况下，以上操作会顺利完成，但有时候也会碰到意外，比如说我们写入文件时系统中断（断定、内核错误等），就会造成数据存放区和元数据区不一致的情况。

那么怎么解决这一问题？早期，就是整个检查存放数据区和元数据区进行对比，然后更新元数据，这个行为可以想见有多麻烦，是非常耗时的。

基于此，导致了后来日志式文件系统的兴起。

## 日志式文件系统
简单来说就是在文件系统中专门分出一个区块用于记录写入或修改文件时的步骤，这样一旦出错就不需要整个进行一致性检查，只需要检查日志，查看是哪个文件出了问题，针对这个出问题的文件及步骤进行修复。

日志文件记录步骤：
1. 当系统要写入一个文件时，会先在日志记录区中记录某个文件准备写入的信息
2. 写入文件的权限和数据
3. 更新metadata
4. 记录文件操作完成

# XFS
ext2系统存在一个很严重的问题：格式化极耗时间。

其根源在于文件格式化时ext2这一类文件系统是预先分配inode区和数据区的，在过去分区不大的情况下表现还行，但是如今磁盘和分区容量日益增大，这种方式就太慢了。

XFS系统对于高容量磁盘有更好的表现。

XFS主要分为三个区：
1. 数据区
2. 登陆区
3. 实时运行区

另外就是XFS的区块容量设置范围更灵活，数据区块是512B-64K，inode区块是256B-2kB

## data section
和ext2的区块群组类似

## login section
和日志区块类似

## realtime section
文件建立时，xfs会使用一些extend区块进行放置，等分配完成后，再写入到data section

extend区块的大小在格式化时确定，4K-1G

## `xfs_info`
通过`xfs_info`指令可查看xfs系统信息

# 文件系统管理
一台计算机中，根据需要可能会使用很多磁盘，有很多分区，每个分区使用不同的文件系统也是可能的

## 查看支持的文件系统
使用以下命令可以查看系统支持的文件系统：
```shell
ls -l /lib/modules/$(uname -r)/kernel/fs
总用量 20
-rw-r--r--. 1 root root 5992 10月 19 2020 binfmt_misc.ko.xz
drwxr-xr-x. 2 root root   25 5月   3 23:20 btrfs
drwxr-xr-x. 2 root root   30 5月   3 23:20 cachefiles
drwxr-xr-x. 2 root root   24 5月   3 23:20 ceph
drwxr-xr-x. 2 root root   24 5月   3 23:20 cifs
drwxr-xr-x. 2 root root   26 5月   3 23:20 cramfs
drwxr-xr-x. 2 root root   23 5月   3 23:20 dlm
drwxr-xr-x. 2 root root   26 5月   3 23:20 exofs
drwxr-xr-x. 2 root root   24 5月   3 23:20 ext4
drwxr-xr-x. 2 root root   60 5月   3 23:20 fat
drwxr-xr-x. 2 root root   27 5月   3 23:20 fscache
drwxr-xr-x. 2 root root   42 5月   3 23:20 fuse
drwxr-xr-x. 2 root root   24 5月   3 23:20 gfs2
drwxr-xr-x. 2 root root   25 5月   3 23:20 isofs
drwxr-xr-x. 2 root root   24 5月   3 23:20 jbd2
drwxr-xr-x. 2 root root   25 5月   3 23:20 lockd
-rw-r--r--. 1 root root 5212 10月 19 2020 mbcache.ko.xz
drwxr-xr-x. 6 root root  137 5月   3 23:20 nfs
drwxr-xr-x. 2 root root   46 5月   3 23:20 nfs_common
drwxr-xr-x. 2 root root   24 5月   3 23:20 nfsd
drwxr-xr-x. 2 root root 4096 5月   3 23:20 nls
drwxr-xr-x. 2 root root   27 5月   3 23:20 overlayfs
drwxr-xr-x. 2 root root   27 5月   3 23:20 pstore
drwxr-xr-x. 2 root root   28 5月   3 23:20 squashfs
drwxr-xr-x. 2 root root   23 5月   3 23:20 udf
drwxr-xr-x. 2 root root   23 5月   3 23:20 xfs
```

## 文件系统分类
传统文件系统
- ext2
- minix
- FAT
- iso9660

日志式文件系统
- ext3
- ext4
- ReiserFS
- Window'S NTFS
- IBM'S JFS
- SGI'S KFS
- ZFS

网络文件系统
- NFS
- SMBFS

## VFS（Virtual FileSystem Switch）
Linux通过VFS进行文件系统管理

层次
- 用户界面
  1. 使用者进程
- 内核
  1. 系统接口
  2. VFS
  3. 各类文件系统
  4. 高速缓存
  5. 设备驱动程序
- 硬件
  1. 硬件设备驱动器

## 查看文件系统信息
### `df`
列出文件系统的整体磁盘使用量
```shell
df [参数] [目录/文件名]
```

参数
- `-a` 列出所有的文件系统，包括系统特有的/proc等文件系统
- `-k` 以kBytes的容量进行显示
- `-m` 以mBytes的容量进行显示
- `-h` 以最高容量单位进行显示
- `-H` 进制由1024改为1000进行换算
- `-T` 将硬盘分区的文件系统列出
- `-i` 不用硬盘容量，用inode数量显示

范例：
```shell
[root@localhost 下载]# df
文件系统          1K-块    已用     可用 已用% 挂载点
devtmpfs         915732       0   915732    0% /dev
tmpfs            931516       0   931516    0% /dev/shm
tmpfs            931516   18824   912692    3% /run
……
```

> 注：/dev/shm这个目录实际是内存虚拟出的磁盘，优点是速度非常快，缺点是重启后数据会丢失

可指定目录查看：
```shell
[root@localhost 下载]# df /root/文档
文件系统          1K-块    已用     可用 已用% 挂载点
/dev/sda2      20961280 5646452 15314828   27% /
```

### `du`
查看文件系统的磁盘使用量（查看当前目录所占空间）
```shell
du [参数] [目录或文件名]
```

- `-a` 列出所有文件和目录的容量，默认只列目录
- `-k` kBytes
- `-m` mBytes
- `-h` 最高单位显示
- `-s` 只列出目录所占据的容量，不列名称

# 文件系统性能
## 文件系统大小与磁盘性能
文件系统越大，可能导致读取性能下降，比如说一个文件使用了两个数据区块，一个在最前面的区块，一个在最后的区块，那么读取需要转动的距离就很大，时间也会增加，效率自然降低

## asynchronously
Linux使用了异步机制提升文件读写效率。

我们知道磁盘读写效率低，内存读写效率高，如果我们编辑文件时直接对磁盘进行读写，那么效率很低。

故而这里使用了一种机制，内存加载文件后，没做任何修改时，会标识其数据`Clean`，相对的，如果对文件进行修改，则是在内存中直接修改，并标识数据未`Dirty`，此时修改后的数据只在内存中。

有以下情况数据会同步到磁盘中：
1. 系统会间隔一段时间定时的将Dirty数据同步到磁盘中
2. 正常关机时，系统会进行同步
3. 使用命令，手动强制进行同步

# 链接
## 硬链接
我们回顾下之前查找文件数据的流程
1. 从目录inode查起，从inode区块中获取data区块位置
2. 确认有rx权限，查询data区块内容，从data区块中通过文件名查阅出对应的inode
3. 获取文件名对应`inode`区块，从中获取data区块位置
4. 确认有r权限，进入data区块，查看内容

硬链接与目录的data区块相关，会在里面加一条文件及其inode的对应记录，这就是硬链接。

看一下硬链接的好处：
1. 不会使用inode、data区块，节省了空间
2. 安全，删除链接之后，原文件还在
   1. 注意，我们通过ll查看时，有一个信息就是链接数，可以通过链接数了解有多少个文件名链接到这个文件
3. 速度，相比符号链接，速度更快【因为查找步骤更少】

缺陷：
1. 不能跨文件系统
2. 不能硬链接目录
   1. 因为一旦要链接目录，必须对目录下的所有子文件都进行硬链接，有相当大的复杂度，所以不支持

### 建立硬链接
使用`ln`指令，更多用法请自己查找，这里演示一部分：
```shell
ln /etc/crontab . # 在当前目录下硬链接出同名文件
ln /etc/crontab ./abc # 当前目录下硬链接出自定义名称文件
```

```shell
[root@localhost 下载]# ll -i /etc/crontab
34326191 -rw-r--r--. 1 root root 451 6月  10 2014 /etc/crontab
[root@localhost 下载]# ln /etc/crontab .
[root@localhost 下载]# ll -i /etc/crontab crontab
34326191 -rw-r--r--. 2 root root 451 6月  10 2014 crontab
34326191 -rw-r--r--. 2 root root 451 6月  10 2014 /etc/crontab
```
注意链接数由`1`变成了`2`，这个链接数标识有多少个文件名链接到这个`inode`号码

## 符号链接
和普通文件一样，使用inode区，inode区指向数据区，数据区内记录了链接文件的文件名。

### 建立符号链接
同样使用`ln`命令，不过要带上`-s`参数，更多使用见文档


```shell
[root@localhost 下载]# ll -i /etc/crontab ./crontabS
35200547 lrwxrwxrwx. 1 root root  12 5月  21 07:09 ./crontabS -> /etc/crontab
34326191 -rw-r--r--. 2 root root 451 6月  10 2014 /etc/crontab
```
注意，这里硬链接数还是`2`，没有增加，因为符号链接使用了新的`inode`和`data`区

## 关于目录的链接数量
有两个特殊目录`.`和`..`，我们观察下建立目录时两者的变化

```shell
[root@localhost 下载]# ll -d ./t1
drwxrwxrwt. 2 root root 6 5月  18 12:47 ./t1
[root@localhost 下载]# mkdir ./t1/t2
[root@localhost 下载]# ll -d ./t1
drwxrwxrwt. 3 root root 16 5月  21 07:14 ./t1 # 注意这里增加了1
[root@localhost 下载]# ll -d ./t1/t2
drwxr-xr-x. 2 root root 6 5月  21 07:14 ./t1/t2 # 这里链接的两个文件名是 /root/下载/t1/t2 /root/下载/t1/t2/. 所以一开始创建的新目录至少都有2个链接
```
