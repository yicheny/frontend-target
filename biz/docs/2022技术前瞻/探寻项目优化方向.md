[TOC]

# 痛点
- 启动本地服务慢
- npm依赖系统混杂
- 打包慢【esbuild、swc】

# `pnpm`
## 速度
总结速度对比就是：pnpm > yarn > yarn PnP > npm

> 注：在存在缓存的情况下，`yarn PnP`是速度最快的

![pnpm下载速度对比](https://camo.githubusercontent.com/83b108abddef5c40f6afc985fa8214edc92b6f2226a83d577074a720907463c8/68747470733a2f2f706e706d2e696f2f696d672f62656e63686d61726b732f616c6f7474612d66696c65732e737667)

这是`pnpm`的优势之一：速度是同类工具中最快的。

## 依赖
以下我会进行一组对比。

首先是`vite-react-demo`，这是我利用`vite`创建的模板项目，创建方式不重要。

我们看一下`package.json`：
```json5
{
  //其他属性
  "dependencies": {
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  },
  "devDependencies": {
    "@types/react": "^17.0.33",
    "@types/react-dom": "^17.0.10",
    "@vitejs/plugin-react": "^1.0.7",
    "typescript": "^4.4.4",
    "vite": "^2.7.2"
  }
}
```
可以看到共有7个首层依赖。

这是我们使用`pnpm`安装的结果：
![pnpm](https://pic.imgdb.cn/item/61f36fa22ab3f51d91afe9a4.jpg)

可以看到除了`.bin`和`.pnpm`两个公共目录，其他都是**首层依赖包**，非常清爽和干净。

这是使用`yarn`安装的结果：
![yarn](https://pic.imgdb.cn/item/61f370612ab3f51d91b096db.jpg)

`otcd`项目我也进行了同样的测试，结果也是类似的，使用`pnpm`的`node_modules`目录基本只有首层依赖，非常干净。

简单说一下为什么`pnpm`的下载结果只有首层依赖？

1. 在`npm 3`版本之前`npm`都是将首层依赖的依赖包安装在对应目录下，但是这种做法缺陷很明显，会造成重复下载依赖
2. 在`npm 3`开始处理这个问题，`npm`会对比所有需要的依赖包，有一个包的兼容范围，比如说假设`lodash`的`2.0.0`到`2.3.9`范围是完全兼容的，然后我们首层依赖多层使用了`lodash`这个包，那么`npm`只会下载兼容范围内最新的包，以此减少重复下载
3. 因而子层级的包也被放在了首层目录中，造成首层目录的臃肿。
4. 而`pnpm`则是将首层依赖所依赖的包放在`.pnpm`目录下，这样就可以在避免重复下载的同时，保证首层目录的干净

为什么要保证首层依赖的干净？
1. 方便开发者在需要的时候查找相关顶层依赖代码
2. 权限严格：原本node_modules的扁平结构使得非顶层`npm`包也可以直接访问，比如实际项目中我遇到过有人在没有指定顶层依赖的情况下直接使用软件包，比如`react-router`和`queryString`

除了速度和目录方面的优势，在内存占用上`pnpm`也有极大的优势，这里我们先介绍下`yarn PnP`

## 关于`PnP`特性【即插即用】
`PnP`是facebook针对`yarn`的痛点给出的解决方案，首先是在`facebook`内部测试使用，2018年9月公开。

> 注：yarn PnP特性必须将yarn升级到2以上才能升级，facebook考虑到兼容问题，默认安装yarn都是1.x版本，升级2以上只要手动执行命令`yarn set version berry`

### 解决问题
直接原因是为了解决`yarn`的两个痛点：
1. 引用依赖慢
2. 安装依赖慢

首先看一下引用依赖时的问题。

node在处理依赖引用时，会有以下两种情况【这里对内部模块解析只是简化说明】：
1. 如果我们传给`require()`调用的参数是一个核心模块（比如`fs`、`path`等）或者是一个本地相对路径（比如`./views/v1`），那么node会直接使用对应的文件
2. 如果不是前面描述的情况，那么Node会开始寻找一个叫做`node_modules`的目录
   1. 首先`Node`会在当前目录寻找`node_modules`，如果没有则到父目录查找，以此类推到系统根目录
   2. 找到`node_modules`目录之后，再在该目录中寻找名为`moduleName.js`的文件或者是名为`moduleName`的子目录

所以`Node`在解析依赖是需要进行大量的文件I/O操作，效率不高。

在看一下在安装依赖时的情况，执行`yarn`会执行以下4个步骤：
1. 将依赖包的版本区间解析为某个具体的版本号
2. 下载对应版本依赖的 tar 包到本地离线镜像
3. 将依赖从离线镜像解压到本地缓存
4. 将依赖从缓存拷贝到当前目录的 node_modules 目录

主要是第4步，涉及到大量I/O操作，导致安装效率不高（尤其是CI环境，每次都需要安装全部依赖）

### 实现原理
facebook工程师针对这些问题决定给出一个可以彻底解决问题并且可以和现有生态进行兼容的解决方案，这个方案就是`PnP`。

说一下PnP的具体工作原理，作为将依赖从缓存拷贝到`node_modules`的替代方案，Yarn会维护一张静态映射表，该表包含了以下信息：
1. 当前依赖树中包含了哪些依赖包的哪些版本
2. 这些依赖包是如何相互关联的
3. 这些依赖包在文件中的具体文职。

这个映射表对应的就是目录中的`.pnp.js`文件

这个`.pnp.js`是如何生成且使用的呢？

在安装依赖第4步时，Yarn不会拷贝依赖到`node_modules`目录，而是会在`.pnp.js`中记录下该依赖在缓存中的具体位置，这样就避免了大量的I/O操作同时项目目录也不会有`node_modules`目录生成。

同时，`.pnp.js`还包含了一个特殊的`resolver`，Yarn会利用这个特殊的`resolver`来处理`require`请求，该`resolver`会根据`.pnp.js`文件中包含的静态表直接确定依赖在文件中的具体位置，从而避免了现有实现在处理依赖引用时的I/O操作

这里我们总结下`PnP`的好处：
1. 安装依赖速度空前提升
2. `CI`环境中的多个CI实例可以使用同一份缓存
3. 同一个系统中的多个项目不再需要占用多分磁盘空间

### 使用
首先要开启`pnp`特性
1. `cra`已经做了集成，只需要在项目中添加`--use-pnp`即可
2. 已有项目执行`yarn --pnp`即可开启

在`package.json`配置：
```json
{
   "installConfig": {
      "pnp": true
   }
}
```

由此可见，`Plug'n'Play`【即插即用】这个特性对我们来说是很有意义的。

现在`pnpm`也支持`pnp`特性，这是使用`pnp`模式下载依赖的`node_modules`结果：

![](https://pic.imgdb.cn/item/61f3a1752ab3f51d91e0f1eb.jpg)

然后是内存方面的对比，这是`yarn`下载的：
![](https://pic.imgdb.cn/item/61f3a2942ab3f51d91e27008.jpg)

这是`pnpm`普通模式下载：
![](https://pic.imgdb.cn/item/61f3a2582ab3f51d91e20956.jpg)

这是`pnpm`使用`pnp`特性下载：
![](https://pic.imgdb.cn/item/61f3a2432ab3f51d91e1f013.jpg)

# `esbuild`
打包工具目前主流有：`esbuild`、`swc`、`babel`这几种

从速度上来看：`esbuild` ≈ `swc` >> `bebel`

![](https://github.com/evanw/esbuild/raw/master/images/benchmark.svg)

esbulid和swc几乎都是babel的几十倍速度，不过我个人推荐使用`esbulid`，原因在于：
1. esbuild的开发者是`Figma`【一个向量图形编辑器和原型设计工具】的`CTO`，而`swc`者是一个97年的年轻人，他写`swc`的时候还只是大二。
2. 另一方面来说，很多成熟的工具，比如`vite`选择了`esbulid`作为打包工具
3. github关注数来看，esbulid是30.9k，而swc是19.9k，相差50%

`esbuild`和`swc`之所以比`bebel`快这么多，主要是开发语言上的差距，`bebel`本身是非常优秀的，可惜它是使用`js`开发的，`js`是单线程、解释性语言，相比较多线程、编译型语言性能上差距很大，而`esbuild`是使用`go`开发的，`swc`是使用`rust`开发的。

使用`esbuild`将有效提升我们的启动速度和打包速度。

实际在项目中应用的问题在于如何兼容webpack？