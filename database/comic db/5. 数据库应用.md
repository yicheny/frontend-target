[TOC]

# 事务(transaction)
我们先看一个数据库操作的案例：

![](https://pic.imgdb.cn/item/61a35d8a2ab3f51d91380ce7.jpg)

数据库原本记录的苹果数量是5，现在再加5，5+5=10，数据库里苹果记录的数量应该是10个。

我们想象一下，如果有两个人同时进行这个操作，可能会出现什么情况？

![](https://pic.imgdb.cn/item/61a35ed42ab3f51d91412992.jpg)

- 初始数量：5
- 左边的女孩数据：5 -> 10
- 右边的女孩记录数据：10 -> 10

现在两个人都加了5，5+5+5=15，数据库的苹果数量应该是15个，但是如果是图里的做法，数据库记录的数据结果会是`10`

数据库需要解决这种数据修改的矛盾，那么数据库是怎么处理的呢？

这就需要提到事务和锁，数据库使用事务和锁机制解决这种矛盾。

事务的定义：访问并可能更新数据库中各种数据项的一个程序执行单元

简单理解就是，处理数据的执行单元

![](https://pic.imgdb.cn/item/61a361ca2ab3f51d9155df0b.jpg)

我们将左边女孩的读取和写入归为一个事务，将右边女孩的读写和写入也归为一个事务。

## 锁(lock)
事务是基本执行单元，数据库对事务执行进行控制，控制的手段就是锁，

我们先回到刚刚的故事：

![](https://pic.imgdb.cn/item/61a3664b2ab3f51d917686f7.jpg)

事务1进行操作时，其他事务不能进行操作，这种控制方案就是锁。

对于这个故事，合理的事务执行流程应该是这样的：

![](https://pic.imgdb.cn/item/61a367662ab3f51d917e8050.jpg)

## 提交(commit)
事务操作完成时，要确认对数据库的处理，这个确认提交的过程我们称之为“提交（commit）”

![](https://pic.imgdb.cn/item/61a379ba2ab3f51d91013cbf.jpg)

## 独占锁和共享锁
回到锁，刚刚介绍的锁是排他类型的锁，也叫做**独占锁**，使用这种锁，当前事务完成前，其他事务读和写的操作都不能执行。

除了排他锁，还有一种锁，叫做**共享锁**，当前事务完成前，虽然还是不能进行写操作，但是可以进行读操作

![](https://pic.imgdb.cn/item/61a37f2e2ab3f51d9126333d.jpg)

使用锁控制多个事务我们称之为**同时执行控制**

## 死锁
通过锁机制进行同时执行控制并不是完美无缺的，依旧可能出现问题。

比如说，现在A需要使用西瓜数据，B需要使用香蕉数据，两个人分别对数据加锁，这一步没有问题。

![](https://pic.imgdb.cn/item/61a381642ab3f51d91359e42.jpg)

假设现在A还需要使用香蕉数据，B还需要使用西瓜数据，那么这个时候会发生什么？

我们之前说过事务使用数据前，需要先加锁，所以A会尝试给香蕉加锁，B会尝试给西瓜加锁。（这是悲观锁的情况，乐观锁的情况不一样）

![](https://pic.imgdb.cn/item/61a382a02ab3f51d913e7ce4.jpg)

加锁的时候，A发现香蕉被B事务加锁了，B发现西瓜被A事务加锁了，两个事务这个时候只能等待对方解锁

![](https://pic.imgdb.cn/item/61a3835d2ab3f51d914382e2.jpg)

然而事务没结束前，原本的锁会一直占有，那么A和B的等待会一直持续着，永远无法结束

![](https://pic.imgdb.cn/item/61a384a52ab3f51d914c3468.jpg)

## 回滚(rollback)
以刚刚的故事为例，两个事务只要一个释放锁，问题就可以解决。

如果一个事务持续待机，这个时候取消事务是合理的做法，取消事务我们称之为“回滚”

回滚是取消事务进行的**所有操作**，比如说有个事务操作是“将所有水果类型数据的数量减1”，它已经处理苹果、橘子、香蕉等数据，只剩下西瓜数据一直在等待中。

![](https://pic.imgdb.cn/item/61a388a52ab3f51d9166f628.jpg)

 如果对该事务进行回滚，那么必须将事务开始到现在的所有操作进行回滚，而不只是回滚当前对西瓜数据的等待

 ![](https://pic.imgdb.cn/item/61a389882ab3f51d916ce82d.jpg)

 需要记住：**事务必须以提交或回滚中的任何一个结束，不能中途结束**

 如果一切正常，则以提交结束

 ![](https://pic.imgdb.cn/item/61a38b022ab3f51d9176d2dc.jpg)

 如果出现异常，则以回滚结束

 ![](https://pic.imgdb.cn/item/61a38b5b2ab3f51d9179130c.jpg)

 ## 两相锁
刚刚所说的这种加锁规则叫做**两相锁**，两相锁又叫做两阶段锁，就是说有两个阶段：加锁和解锁

为保证事务的可序列化，锁的使用有其规则，两相锁正是其中之一。

可以证明，若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。

## 一次封锁法
和两相锁稍有区别，这种做法一次将所有需要使用的数据都加锁，这种做法可以避免死锁。

![](https://pic.imgdb.cn/item/61a418952ab3f51d91017d25.jpg)

一次封锁法同样是两相锁，应该说是两相锁的一个子集，只符合两相锁的定义可能导致死锁问题

一次封锁法的缺陷也同样明显，如果一个事务涉及资源较多，那么需要同时封锁很多资源，从资源利用率上来说并不友好。

 ## 事务的性质`ACID`
 为了避免数据发生矛盾，事务必须具有如下性质，这些性质我们称作`ACID`属性

| 性质 | 内容 | 说明 |
| --- | --- | --- |
| A（Atomicity） | 原子性 | 事务的所有操作要么全部反映，要么都不反映（可以认为要么提交，要么回滚） |
| C（Consistency） | 一致性 | 事务执行时，需要保持数据库的一致性 |
| I（Isolation） | 隔离性 | 事务相互隔离，一个事务不能看到另一个事务运行中间时刻的数据 |
| D（Durability） | 持久性 | 事务完成后，数据持久性的保存在数据库，即使出现故障也不会被回滚 |

## 隔离级别
现实数据库操作里，随着事务的不断增加，我们需要控制事务之间互相干涉的级别，这叫做**隔离级别**

写法示例：
```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
```

| 隔离级别 | 脏读 | 非重复读 | 虚读 | 
| --- | --- | --- | --- |
| READ UNCOMMITTED | 可能发生 | 可能发生 | 可能发生 |
| READ COMMITTED | 不发生 | 可能发生 | 可能发生 |
| REPEATABLE READ | 不发生 | 不发生 | 可能发生 |
| SERIALIZABLE(默认) | 不发生 | 不发生 | 不发生 |

既然级别越高越好，为什么保留`SERIALIZABLE`就好？

因为级别越高，数据越安全，但性能越低。

## 脏读
事务1提交前，事务2读取该行，事务1进行回滚的情况下，事务2读取了不存在的行的情况

> 一个线程的事务读到了另一个线程的事务未提交的数据

![](https://pic.imgdb.cn/item/61a41e3f2ab3f51d91032179.jpg)

## 非重复读
事务1进行**读取**某行时，事务2在**更新**该行并提交时，事务1再一次读取数据，发生数值不一致的情况

> 一个线程中的事务读取到了另外一个线程中提交的update的数据。

![](https://pic.imgdb.cn/item/61a41fe12ab3f51d91038f54.jpg)

## 虚读
事务1进行**检索**，获得多行结果，事务2**追加**了符合该条件的行，事务1第二次检索的结果不同的情况

> 一个线程中的事务读取到了另外一个线程中提交的insert的数据。

![](https://pic.imgdb.cn/item/61a4217e2ab3f51d91041772.jpg)

 ## 粒度
 两种：
 - 表格粒度
 - 行粒度

 ## 其他锁
 //TODO 待补充时间锁和乐观锁

 # 安全控制
 主要是通过权限控制

 数据操作权限：
 - `SELECT` 检索
 - `INSERT` 插入
 - `UPDATE` 更新
 - `DELETE` 删除
 - `ALL` 所有权限

这些权限通过`GRANT`命令赋予，示例
```sql
GRANT SELECT,INSERT ON 学生表 TO 李白【操作者】
```

使用`WITH GRANT OPTION`命令时，被授予权限的用户可以再授予其他用户权限
```sql
GRANT SELECT,INSERT ON 学生表 TO 李白
WITH GRANT OPTION
```

通过`REVOKE`可以收回权限
```sql
REVOKE SELECT,UPDATE ON 学生表 TO 李白 
```

# 索引
在关系数据库中，如果没有设置索引，数据是无需摆放的，随着数据的增多，查询速度会变得很慢。

一般情况下，优化查询是通过索引进行的，索引是优化查询时最常用的一种手段。

下面介绍一些我关于“索引”的经历。

以前我写爬虫时就用过索引，当时我将一个影视网站的数据整个爬了下来，存储到`mongooseDB`数据库中，数据包括数十万部电影信息，每部电影信息都较为详尽，包括参与演员、发行年份、评分、标签等等。

在没有建立索引的情况下查询指定信息，比如说某个演员相关的所有电影，速度是很慢的，大概需要几十秒左右，之后我将演员作为键建立索引，查询速度是`0.0006`秒，速度提升可见一斑。

我们创建对象存储区【表】时，必须指定主键，在有些关系型数据库中，如果建表时没有指定主键，则不允许创建。有些数据库允许创建没有主键的表，此时数据是无序存放的。

主键是最通用的索引，非常重要。因为索引不是无序放置数据的，它会以特定的数据结构进行存储，查询速度会得到极大提升。

不过索引并不一定是主键，主键只有一个，索引可以有很多个。

索引有`uniq`属性，以控制键是否唯一，比如姓名啊、身高这种就并不唯一，可以重复；而身份证号、`id`这种需要保证唯一。

索引的数据结构实现，根据不同数据库会有不同实现，常见的有3种：
1. 桶结构【分类合并】
2. 哈希表【散列表】
3. `B-tree`【平衡树——这个用的最多】

我们看一下使用这三种结构查询效率会有什么不同，

## 桶结构
首先是桶结构，假设现在表结构是这样的，我们使用身高作为索引。

| 身份证号 | 姓名 | 性别 | 身高 |
| --- | --- | --- | --- | 
| 999999101 | 李白 | 男 | 180 |
| 999999102 | 貂蝉 | 女 | 164 |
| 999999103 | 杜甫 | 男 | 177 |
| 999999104 | 杨玉环 | 女 | 172 |

假设这种数据有百万条以上，我们想找到其中的杨玉环，我们希望找到其中名叫杨玉环的女性，可惜当初没有为姓名建立索引，现在唯一的索引就是身高。

另外，关于杨玉环，我们还知道的信息是她的身高是164。

我们先看下桶结构索引是怎么存储的：
1. 准备100个桶【内存地址】，分别用于标识`100【最小值】`-`200【最大值】`的身高 
> 最大最小值很容易拿到，而且也很容易修改

<!-- ![]() -->

2. 存储数据时，将数据放到对应的桶里

<!-- ![]() -->

3. 查询数据时，比如查`164`，请问查询速度是多少？

答案是`O(1)`

桶结构在排序时有奇效，比如我们如果想要为刚刚的信息以身高进行排序，我们以桶结构存储，查询时依次从桶中取出数据，得到的就是排序后的结果了

<!-- ![]() -->

> 这里特别说明下，正常初始和结束的桶都不会是空的，空的只会是中间桶，原因各位可以想一想

可以发现，如果以桶结构存储，排序超级快速，即便是百万级别，千万级别的数据，桶排序速度始终稳定是`O(1)`。

不过如此强大的桶排序，并不适用于所有场景，它的缺陷在于：
1. 内存空间的浪费

假设现在我们要对`(1,100000000)`这两个数字进行排序，那么桶排序会占据`100000000`（1亿）个内存地址，这很显然比较浪费。

2. 对于非整数类的数据难于放置

比如现在有一个属性是价格，它的区间不大，只是`0-1000`，但是它的精细度是`0.00000001`，这种时候用桶结构就不太合理。

## 哈希表
...待补充

## `B-tree`
...待补充

## 不要建立太多索引
原因：
1. 占据过多的存储空间
2. 每次数据更新，索引也需要更新，如果索引过多，会降低更新效率

# 故障恢复
数据库有提供故障恢复功能，比如说在运行中突然断电，也是可以恢复的

数据库恢复一个很重要的文件是“日志”，日志是数据库处理数据时生成的记录。

日志的记录内容包括
1. 用户对数据库的变更操作
2. 数据更新前后的值（这个很关键）

## 故障种类
基本有三种：
1. 事务故障：比如死锁
2. 系统故障：比如说停电这种情况
3. 介质故障：比如说硬盘出现问题【需要定期备份，基于备份文件进行恢复】

## 检查点
在实际的数据库应用中，为提供数据库效率，基本都会使用缓存。它会有一个检查点，缓存和检查点的数据保持一致。

我们将事务分成三种状态：
1. 未开始
2. 开始但没有提交
3. 提交完成

针对这三种状态，采取的方案分别是
1. 无需处理
2. 回滚
3. 前卷法

![](https://pic.imgdb.cn/item/61a3facf2ab3f51d91fa6864.jpg)

以这个图来看，其中
1. T1事务在检查点前已开始，故障发生时还没有提交，所以需要回滚
2. T2事务在检查点后已提交，需要进行前卷
3. T3事务在检查点前已提交，无需处理

这里我们介绍下前卷法

## 前卷法(roll forward)
如果提交操作已完成，那么日志会记录更新后的数据。

故障发生后，提交完成的事务，将其数据恢复至更新后的数据即可，这种恢复方式被叫做前卷法

# 资料
- [图片-蕾米莉亚](https://www.pixiv.net/artworks/66088599)
- [图片-旧作爱丽丝](https://www.pixiv.net/artworks/54550636)
- [图片-琪露诺](https://www.pixiv.net/artworks/66022662)