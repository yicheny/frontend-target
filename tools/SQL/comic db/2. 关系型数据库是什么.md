[TOC]

# 数据库模型
数据库模型定义了数据的逻辑设计，描述了不同数据之间的联系。

有三种数据模型最为经典。

## 层次数据模型(Hierarchical data model)
第一种，层次数据模型，由“根”开始向下扩展，一个母数据对应多个子数据，一个子数据对应一个母数据，是“一对多”的关系，如图

![层次数据模型](https://pic.imgdb.cn/item/61a1e4a82ab3f51d9114aa32.jpg)

## 网状数据模型(network data model)
第二种，网状数据模型，一个母数据可以对应多个子数据，一个子数据也可以对应多个母数据

![网状数据模型](https://pic.imgdb.cn/item/61a1e5ad2ab3f51d91151248.jpg)

## 关系型数据模型(relational data model)
第三种，是关系型数据模型。

关系模型中，数据组织成 称为“关系” 的二维表，数据间没有强制的层次和网状结构，表之间通过关系相互关联。

> 注：下图出自《计算机科学导论》

![关系型数据模型](https://pic.imgdb.cn/item/61a1e6742ab3f51d91156435.jpg)

我们知道，现在主流的数据库模型方案是关系型数据库，为什么？

最直接的答案就是：前两种太复杂了，关系型数据库最简单。

我们看一下数据体系结构：

![数据库体系结构](https://pic.imgdb.cn/item/61a1e9ff2ab3f51d9116dc07.jpg)

如果是前两种模型，它们使用指针连接数据表示它们的关系。使用指针的话，就需要使用者控制指针处理内存。

内存，通常指虚拟内存，是机器对实际物理地址的抽象，下面这段总结出自《汇编语言》
- 物理存储器整体都被看作一个由若干存储单元组成的逻辑存储器
- 每个物理存储器在这个逻辑存储器中占有一个地址段
- CPU在这段地址空间内读写数据，实际上就是在相对应的物理存储器中读写数据
- 在基于计算机硬件系统编程时，必须了解这个系统的内存地址空间分配情况
- 当开发者想要在某类存储器中读写数据时，必须知道它的第一个单元地址和最后一个单元地址，才能保证读写是在预期存储器中进行的

简单来说就是：如果你基于计算机硬件进行编程，那么你就必须了解系统的内存空间地址分配情况，这样才能保证数据读写是针对预期存储器进行的。

事实上也正是，想要操作层次性数据模型或网状数据模型，，需要了解数据在机器上的位置，知道它们很怎么存储的，这使得用户的使用负担很重

而关系型数据库解决了这个问题。

这里我要稍微说一下关系型数据库的诞生背景。

> 内容来源：《编程之魂：与27位编程语言创始人的对话》& 《SQL进阶指南》

说到关系模型，有一个肯定离不开的人，那就是埃德加·弗兰克·科德（英语：`Edgar Frank Codd`， 1923年8月23日－2003年4月18日），他是关系模式的创始人。

通常认为关系型数据库的起源是，Codd在1970年的发表的一篇具有里程碑意义的论文《一个对于大型共享型数据库的关系模型》

Codd首创了关系模型理论，他为关系型数据库理论做出了奠基性的贡献。

1981年，科德因在关系型数据库方面的贡献获得了图灵奖。

关于科德更详细的介绍见：[wiki-科德](https://zh.wikipedia.org/wiki/%E5%9F%83%E5%BE%B7%E5%8A%A0%C2%B7%E7%A7%91%E5%BE%B7)

那么科德是基于什么理由创造了关系型数据库呢？

科德从牛津大学数学专业毕业后，作为英国空军飞行员参加了第二次世界大战，战后前往美国，在IBM公司从事开发工作

在20世纪70年代初期，集成数据库刚开始出现，这个时候企业第一次将数据库作为公共资源，这个时候，无论是技术上还是经济上，都是一个非常火热的技术，跟现在的“机器学习”有些类似。

这个时候科德在IBM公司工作，是一个实验室小组的领导者，除了科德的小组，IBM还有很多其他小组在研究数据库的问题。

比如说，SQL语言的实现者`D.D.Chamberlin`和`R.F. Boyce`，SQL是对关系模型的首个商业化语言实现。

当时IBM使用的数据库是`IMS`，`IMS`是层次性数据库，顺便一提，层次性数据库也是IBM首创的。

科德致力于创建一种简单，并且灵活的数据模型，关系模型就是他的成果，关系模型简单而优雅，并且足够灵活。

在科德1970论文的序言中，他这么写道：

“使用终端或应用程序的大型数据库用户不需要知道数据在机器上是如何存储的。坐在终端前的用户和应用程序的行为不应该受到数据库内部结构变更的影响”

科德在这篇论文中第一次明确指出：**关系模型应该在表现层放弃指针**

## SQL是什么？
`Structured Query Language`（结构化查询语言）是一种特定目的编程语言，是对关系模型的语言实现。

更多内容见[wiki-SQL](https://zh.wikipedia.org/wiki/SQL)

# 数据库术语
我们先拿出一份记录数据的文档

![](https://pic.imgdb.cn/item/61a23ec52ab3f51d913686e4.jpg)

## 记录(record)、字段(filed)
文档的每一条数据叫做**记录(record)**，记录每个的内容项叫做**字段(filed)**

![](https://pic.imgdb.cn/item/61a2407e2ab3f51d91372cee.jpg)

可以发现不同的记录中**字段的类型是一致的**，比如说学生编号都是3位的数字，学生名称都是小于4位的字符串

## 空值(null)
有些字段可以为空，为空不是说必须输入空，而是说这一项可以不填

![](https://pic.imgdb.cn/item/61a241c72ab3f51d9137906e.jpg)

## 关系(relation)
关系型数据模型以二元表格（table）为基础，在关系型数据中，我们将表格称作关系(relation)

![](https://pic.imgdb.cn/item/61a244612ab3f51d91387f07.jpg)

## 行(row)、列(column)
- 一条数据，也就是记录，在关系型数据模型中称作**行(row)**
- 一个内容项，也就是字段，在关系型数据模型中称作**列(column)**

![](https://pic.imgdb.cn/item/61a245642ab3f51d9138e100.jpg)

## 键(key)
在数据中，具有重要意义的字段被称作**键(key)**。

这个重要意义就是定位数据，分为主键和外键两种。

## 主键(primary key)
一般来说每张表都应该有主键，有些SQL实现，如果不设置主键根本不允许创建表，有些SQL则允许创建无主键表，此时数据是无序放置的。

通过主键我们可以确定唯一的数据，这是主键的意义，它非常重要。

想要设成主键必须满足两个条件：
1. 主键必须`uniq`（唯一），比如说姓名这种可以重复的字段是不能设置为主键的，我们设定字段时可以决定该字段是否`uniq`
2. 主键不允许为空

![](https://pic.imgdb.cn/item/61a242782ab3f51d9137db97.jpg)

主键是非常重要的字段，对于查询优化它也有着很重要的意义

当然，这是因为主键必然是“唯一性索引”，而其他字段的索引的指向也是主键，而非数据本身。

之后在索引部分，会介绍索引的查询优化原理。就目前来说，我们可以这么认为：索引可以优化查询速度，主键是唯一性索引，那么它必然可以优化速度。

现在我要请你思考一个小问题，如果表格中有唯一性自然是最好，如果表格记录时没有设置唯一性字段，比如说我们将刚刚表格的“登记编号”字段去掉，变成这样：

![](https://pic.imgdb.cn/item/61a252f92ab3f51d9179cdd1.jpg)

我们可以发现现在这张表所有字段都不符合要求，要么字段存在重复，要么字段可以为空。

这个时候我们还可以设置主键吗？

答案当然是可以。

如果可以设置新字段，那么问题就很简单了，当然你确实可以这么做，添加一个具有唯一性的字段作为主键。

不过不添加新字段，也可以设置主键吗？其实也可以做到

那么这个时候要怎么设置主键呢？

提示：主键是逻辑键，而非物理键，它并不需要对应具体的某一个字段

之后我会提到在这种情况下怎么设置主键，这里先稍微思考一下吧。

## 外键(foreign key)
外键，则是一张表里用于参照其他表主键的键，这个不是必须要的。

另外，如果设置外键，外键并不要求唯一。

举个例子，在下图中，课程登记表里，学生编号可以设置为外键，而在另一张表里，学生编号是主键。

![](https://pic.imgdb.cn/item/61a24a042ab3f51d913d46b4.jpg)

通常来说，外键是用于参照数据所用的另一份表的主键。

比如说在课程登记表里只记录了学生编号，并没有记录学生的详细信息，然而通过学生编号我们可以从学生表里获取到唯一的数据。

现在我们试着将两张表合成一张表，执行语句如下：
```sql
SELECT *
FROM courser_register
INNER JOIN student1
ON courser_register.`学生编号` = student1.`学生编号`
```

![](https://pic.imgdb.cn/item/61a252ca2ab3f51d9178876e.jpg)

这种运算叫做`join`运算，细分的话有四种：`inner join`、`left join`、`right join`、`full join`

这里暂时不介绍这几种`join`的区别，之后有需要会再说明。

这里使用`join`运算是为了体现关系型数据库的灵活性，我们通过数学运算来处理数据，`join`正是这种运算中的一种。

接下来会介绍8种数学运算：并、差、交、笛卡尔积、投影、选择、连接、除

当然，我们只需要理解其运算概念即可。

这些运算是关系型数据库的基础，有些被包含在日常操作中，比如说一个简单的查询就包含着选择运算、投影运算；有些需要提供了专门的操作符处理，比如说并集运算、连接运算；而有些可能需要我们自己实现逻辑，比如除运算。

## 数据库专业术语
到这里我们已经介绍了很多数据库术语，比如字段、记录这些，不过这些并不是专业术语，而是日常术语。

下面是一份术语对照表。
> 关于该表，可参考《数据库系统导论 第7版》（机械工业出版社）

| 正式的关系模型术语 | 非正式的日常用语 | 
| --- | --- | 
| 关系(relation) | 表(table) |
| 元组(tuple) | 行(row)、记录(record) | 
| 势(cardinality) | 行数(number of rows) |
| 属性(attribute) | 列(column)、字段(filed) | 
| 度(degree) | 列数(number of columns) | 
| 定义域(domain) | 列的取值集合(pool of legal values) |

# 运算
关系型数据库可以基于数学运算进行数据操作。

下面介绍的这些运算是对多表之间的数据处理，可以分为两类：
1. 集合运算：并、差、交、笛卡尔积
2. 关系运算：投影、选择、连接、除

举一个`union`的实例代码
```sql
SELECT * FROM student1 
UNION
SELECT * FROM student2
```

## 集合运算
### 并(union)
抽取两份表的数据以形成一张表。

![union](https://pic.imgdb.cn/item/61a1f7802ab3f51d911ccd3e.jpg)

![wiki-并集](https://pic.imgdb.cn/item/61a239042ab3f51d91348ce4.jpg)

### 差(difference)
将某张表独有的数据抽取成一张表。

求差有两种情况：

![difference](https://pic.imgdb.cn/item/61a1f8852ab3f51d911d3709.jpg)

![wiki-差集](https://pic.imgdb.cn/item/61a2395a2ab3f51d9134ae09.jpg)

### 交(intersection)
将两张表中都有的数据抽取成一张表

![intersection](https://pic.imgdb.cn/item/61a1f9b22ab3f51d911daa3a.jpg)

![wiki-交集](https://pic.imgdb.cn/item/61a239822ab3f51d9134bc62.jpg)

### 笛卡尔积(Cartesian product)
将两张表中所有行进行排列组合，以形成表。

![笛卡尔积](https://pic.imgdb.cn/item/61a1fe272ab3f51d911f67c0.jpg)

## 关系运算
### 投影(projection)
调取一张表的某些列，以形成表。

![投影](https://pic.imgdb.cn/item/61a1ff4c2ab3f51d911fe9b5.jpg)

### 选择(selection)
与投影类似的是选择，调取一张表的某些行

![选择](https://pic.imgdb.cn/item/61a20fd42ab3f51d91258b44.jpg)

### 连接(join)
连接是通过指定键将不同的表连接到一起。（键的相关知识在下一节）

![连接](https://pic.imgdb.cn/item/61a2128f2ab3f51d9126982b.jpg)

### 除(division)
除运算就是：
1. 从“被除表格”取出“除表格”中包含的所有行
2. 然后从取出的数据中去掉 包含 “除表格” 的部分
   
![除](https://pic.imgdb.cn/item/61a238b22ab3f51d91347218.jpg)