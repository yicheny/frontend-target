[TOC]

# E-R模型
我们设计关系型数据库时，通常会使用`E-R`模型分析法。

这里的`E`是`Entity（实体）`、`R`是`Relation（关系）`

所以`E-R`分析法，就是`实体-关系`分析法

那么这么这里有两个问题：
1. 实体是什么？
2. 关系又是什么？

`E-R`分析法是一种认知世界的方式，使用“实体”和“关系”的概念我们可以为世界上的一切进行建模。

## 实体
首先是实体，实体就是 我们所能认知的 现实世界存在的事物，实体是现实存在的事物。

比如说，每个学生都有身份证、姓名和性别，这些是客观存在的，这里我们将学生作为实体进行描述，得到结果：

![](https://pic.imgdb.cn/item/61a25ad22ab3f51d919c44ef.jpg)

然后是课程，每门课程都有自己的名称、授课教师，上课学生，同样是客观存在的，我们将其作为实体描述，得到结果

![](https://pic.imgdb.cn/item/61a25bd62ab3f51d91a4074c.jpg)

## 关系
有了实体，才会有关系。

什么是关系？

关系就是对实体间关联的描述。

比如说学生和课程之间的关系，可以这么描述：

![](https://pic.imgdb.cn/item/61a25c892ab3f51d91a9b481.jpg)

实体之间的关系个数有三种状态：
1. 一对一
2. 一对多（“一对多”和“多对一”是一种情况）
3. 多对多

## 基数
这种实体间的对应个数我们称之为**基数**

学生和课程之间是多对多的关系，一个学生可以上多门课，一门课可以有多个学生，如图

![](https://pic.imgdb.cn/item/61a25d532ab3f51d91af9853.jpg)

一对一的关系，比如一门课只有一个任课教师，这是一对一；一个老师可以教导多名学生，这是一对多；一个老师可以教授多门课程，这也是一对多；

这里我们可以发现一件事，实体是客观存在的事实，而关系是抽象的概念，这里我认为是设计的一个复杂点，对于抽象的认知并不统一，这还在其次，因为是抽象本身，我们并不能完美的进行描述。

## E-R图基本描述
三部分：
1. 菱形表示关系
2. 矩形表示实体
3. 椭圆形表示属性

![](https://pic.imgdb.cn/item/61a25ec62ab3f51d91ba17f2.jpg)

# 规范化表格
这里首先要说一个范式的概念，范式是符合某一种级别的关系模式的集合。

关系数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式。

顺便一提，范式概念首次出现在科德1970年那篇里程碑式的论文中

给出一份表格数据：

![](https://pic.imgdb.cn/item/61a2f6922ab3f51d9186dedc.jpg)

这种字段可以再分割的情况叫做非范式。

## 第一范式(1NF)
第一范式要求的每个字段都不可再分割。

修改表格得到：

![](https://pic.imgdb.cn/item/61a2f6c32ab3f51d91870c4a.jpg)

一般初入门的人设计数据很容易设计至1NF，不过这个程度作为视图可以，作为存储表而言多数情况下是不合格的，存在很多问题。

我们看下现在1NF存在的问题：
1. **数据冗余**：现在课程编号、学生编号、院系这些内容都重复了很多次，对于存储空间是一个极大的消耗，而且不易于维护，因为重复操作
2. **维护困难**：比如李清照她想转系或者说退学，那么需要多份数据信息
3. **插入异常**：比如说现在学校想新建立一个系，比如说叫做法律系，但是现在没有学生，那么就不能插入信息了【因为字段不能为空】
4. **删除异常**：假如某个系只有一个学生【比如说考古系】，现在这个学生毕业了，我们删除这个学生信息后，院系和系主任的信息就随之丢失了。这并不合理，只是暂时没有学生，但是院系和系主任还在

## 第二范式(2NF)
第二范式消除了**非主属性**对于**码**的**部分函数依赖**

这里引入了几个新概念，介绍下这几个相关概念，首先是函数依赖

### 函数依赖
由属性X可以得到唯一的属性Y的值，这种情况我们就称之为函数依赖。

记作 X->Y，叫做X函数确定Y，或Y函数依赖X

比如：通过身份证号我们可以确定唯一的姓名

### 平凡依赖
如果满足 X->Y，且Y是X的子集，就是平凡函数依赖

> 子集是一个数学概念：如果集合A的任意一个元素都是集合B的元素，那么集合A称为集合B的子集

还是以身份证号举例，通过身份证号我们可以确定身份证上的所有信息，比如说姓名、性别、出生年月，这些信息是身份证号下的子集。

这里直接点说就是，如果Y是X子集的字段，那么必满足 X->Y

### 非平凡依赖
若X->Y，但Y不是X的子集，就是非平凡函数依赖

比如：(课程,学生) -> (分数)，可以看到，只要我们确定了学生和课程，就可以确定对应的分数，然而分数并不是课程的子集（课程下有多个学生的分数），也不是学生的子集（学生有多个课程的分数）。

### 完全函数依赖
若X->Y，且对于X的任何一个真子集X'，都有X'-/->Y，则称Y对X有完全函数依赖，记作X->Y（箭头上有个大写F，表示full）。

![](https://pic.imgdb.cn/item/61a2e6c92ab3f51d9177fd15.jpg)

举个例子：(课程,学生) -> (分数)

这里X是(课程,学生)，这两个任意一个都不能确定分数，这是X'-/->Y，而(课程,学生)【即X】可以确定分数【Y】，这种就叫做Y对X的完全函数依赖

就是说，如果X只有完全的时候，Y才对X有依赖，这也是要求满足任意真子集X'-/->Y的原因，因为一旦X'->Y，那么不需要X保持完整了，只需要X'->Y就可以确定信息了。（这个时候其实就是不完全函数依赖了）

### 不完全函数依赖
若X->Y,但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X->Y（箭头上有个大写P，表示part）。

比如说(课程，学号)->年级，这里我们发现，其实只使用学号就可以确定他的年级，那么就是 学号->年级

对于X的子集就可以确定唯一Y的情况，我们称 X-Y 是部分函数依赖

### 传递函数依赖
如果X->Y(Y不是X的子集)，Y-/->X，Y->Z，Z是Y的子集，则称Z对X传递函数依赖。记为X->Z（箭头上有大写字母T，表示transfer）

![](https://pic.imgdb.cn/item/61a2e9ec2ab3f51d917ad12c.jpg)

解释一下就是：X->Y满足非平凡依赖，Y->Z满足平凡依赖，则XT->Z

比如(课程,学号) -> (系主任)，
1. 学号 -> 院系，这是非平凡依赖
2. 院系 -> 系主任，这是平凡依赖
3. 学号 -> 系主任，这就是传递函数依赖

其实就是：X可以确定Y，Y可以确定Z，所以X可以确定Z，不过这里要注意的是Y不是X的子集。

那么这个时候你可能会问了，如果Y是X的子集呢？

问得好，那这个时候就不是传递函数依赖了，是直接函数依赖

### 直接函数依赖
如果X->Y，Y是X的子集,Y->Z,Z是Y的子集，则称Z对X直接函数依赖。记为 X直接->Z（箭头上是汉字 “直接”）

### 码
什么是码？

设 K 为某表中的一个**属性或属性组**，若除 K 之外的所有属性都**完全函数依赖**于 K，则此时K就是码。

一张表可能会有超过一个码，实际应用中会选择一个作为主码

### 主属性
包含码中的属性就是主属性【无论是否是主码】

### 非主属性
主属性之外剩下的就是非主属性

理解以上之后，我们找到目前表里存在的部分函数依赖，消除掉即可。

我们首先分析：这里的码是什么？

是(课程编号,学生编号)，通过课程编号和学生编号我们就可以确定其他属性的信息。

这样我们可以确定主属性和非主属性了
1. 主属性：课程编号、学生编号
2. 非主属性：课程名称、学生姓名、性别、分数、院系、系主任

其中
- (课程编号，学生编号) -> 分数
- (课程编号) -> 课程名称
- (学生编号) -> 学生姓名、性别、院系、系主任

分析完成之后，消除依赖可以得到3张表

![选课表](https://pic.imgdb.cn/item/61a2f76e2ab3f51d9187a873.jpg)

![课程表](https://pic.imgdb.cn/item/61a2f7932ab3f51d9187ce69.jpg)

![学生表](https://pic.imgdb.cn/item/61a2fc3b2ab3f51d918c2e83.jpg)

回顾之前的问题
1. **数据冗余**：有所改善
2. **维护困难**：有所改善
3. **插入异常**：未解决
4. **删除异常**：未解决

## 第三范式(3NF)
第三范式消除了非主属性对于码的传递函数依赖

主要我们看一下学生信息表，其中 学生编号 T -> 系主任

消除传递依赖关系
- (学生编号) -> 学生姓名、性别、院系
- (院系) -> 系主任

![学生表NF3](https://pic.imgdb.cn/item/61a2fc832ab3f51d918c6bcd.jpg)

![院系表](https://pic.imgdb.cn/item/61a2f82c2ab3f51d9188597e.jpg)

回顾之前的问题
1. **数据冗余**：解决
2. **维护困难**：解决
3. **插入异常**：解决
4. **删除异常**：解决
   
# 参考资料
- [知乎-如何理解关系型数据库的常见设计范式？](https://www.zhihu.com/question/24696366)
- [数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩](https://segmentfault.com/a/1190000013695030)
- [平凡依赖，非平凡依赖，完全依赖，部分依赖，传递依赖，直接依赖的区别](https://www.cnblogs.com/guojiaxue/p/12655068.html)