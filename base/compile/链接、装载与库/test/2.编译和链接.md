
# 预编译
1. 删除注释`//`,`/* */`
2. 添加文件标识和行号信息，便于错误时提示出相关信息
3. 处理`#define`，展开所有宏，将其插入到文件中
4. 将`#include`的文件代码插入到文件，这个过程是递归循环的
5. 处理所有条件预编译指令，如`#if`，`#elif`,`#endif`
6. ...

# 编译
简单来说，就是将高级语言转换为汇编，由3个重要部分组成

## 词法分析
通过扫描器，将代码扫描为Token

举例：
```c
array[index] = (index + 4) * (2 + 6)
```

| token | 类型 | 
| --- | --- | 
| array | 标识符 | 
| [ | 左方括号 | 
| index | 标识符 |
| ] | 右方括号 |
| = | 赋值 |
| ( | 左圆括号 |
| index | 标识符 |
| + | 加号 |
| 4 | 数字 |
| ) | 右圆括号 |
| * | 乘号 |
| ( | 左圆括号 |
| 2 | 数字 |
| + | 加号 |
| 6 | 数字 | 
| ) | 右圆括号 |

## 语法分析
将token转换为语法树，节点是表达式

## 语义分析
语法树不包含动态类型，语义树相比语法的区别是增加了语义层面的分析，比如类型，由于类型的存在我们可以更精细的推导代码正确性。

我们可以针对类似`2+6`的语句进行优化，不过这个由语义树去做会很难，所以通常的做法是生成中间代码，然后进行优化。

由于中间代码的存在，所以编译可以分为前端和后端两部分，前端部分到生成中间代码为止，后端部分从中间代码为始，到目标代码为止。

# 汇编
将汇编转换为机器语言，输出文件叫做目标文件

# 链接
链接做了什么？

