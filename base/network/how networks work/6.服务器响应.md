[TOC]

# 服务器结构
问题：如何区分服务端和客户端。

服务器和客户端机器可以是一样的机器，它们使用着相同的网络协议，可以使用相同的系统和应用软件。

从硬件和软件而言，服务器和客户端机器很难分清，因为两者基本相同，服务器也可以作为客户端机器，客户端机器也可以同时作为服务器。

实际上，区分服务器的关键在于：建立网络连接时，谁是等待连接的那一方？

服务端的TCP和客戶端的TCP略有不同，我们先回顾下客户端TCP过程：
1. 创建套接字
2. 创建TCP包，建立连接
3. 传输
4. 断开

这是服务端的TCP过程：
1. 创建套接字
2. 创建TCP包，等待连接
3. 收到连接，将数据交给通信模块
4. 传输
5. 断开

注意第2、3步，这是和客户端的主要不同。

首先，服务端的TCP不会主动发起连接，而是创建后保持等待状态。

另外，需要注意，服务端的TCP分为两个模块，一个是连接模块，一个是通信模块，连接模块负责等待，有数据可以接收时，会立刻创建当前套接字的副本和客户端请求进行通信。同时，连接模块套接字不变，这里始终需要一个套接字负责等待连接。

为什么服务端的TCP要这么做？从应用程序的角度考虑，一个应用程序和多个客户端同时进行交互是非常复杂和麻烦的，所以实际上采用的策略是，每有一个请求，就运行一个服务端程序与之交互。

另外，这里我们发现一件事，会有1个等待套接字和多个通信套接字使用同一个通信端口，之前在客户端的时候我们说过通过端口匹配唯一的套接字，这里就不适用了。

首先，我们知道客户端发送请求时锁定了服务端的ip和端口，所以端口必然是确定且唯一的。另一方面，这一个端口有多个通信模块，所以必然也不能以端口作为分辨通信模块的标准。

那这里要怎么区分通信模块？

实际上现在的信息已经足够，只要有4部分信息我们就足以分辨通信模块：
1. 服务端ip
2. 服务端端口
3. 客户端ip
4. 客户端端口

通过这4个信息我们可以锁定唯一的通信套接字。

不过，实际上我们并不使用这4个信息分辨套接字，我们创建套接字时会分给它一个描述符，我们使用套接字描述符锁定唯一的套接字。

为什么使用套接字描述？
1. 套接字描述更简短，占用内存更少
2. 使用1种信息比使用4种信息简单
3. 等待连接时没有客户端信息

## 优化连接速度
我们知道服务端会在接收到连接后，创建套接字然后进行通信，但这样的话，这里必须先等待套接字创建，然后再进行通信，这样就会降低通信的效率。

有一个简单的优化方案时，在等待连接时，就创建几个通信模块，如果有连接进行直接分配一个通信模块即可，这样就省下了等待创建套接字的过程

# 服务器接收过程
## 网卡
网卡接收到的信息是电信号/光信号，需要将其转换为数字信号。

转换时首先要通过时钟信号确定传输速率，然后定位到起始帧，将数据部分转换为数字信号。【MAU/PHY模块】

客户端网卡封装的包：报头【时钟信号】 + 起始帧 + mac报头 + ip报头 + tcp报头 + 应用程序数据 + FCS

转换之后的数字信息部分不再需要时钟信号和起始帧，它会使用FCS检验数据，如果没有通过校验，则说明数据失真，直接丢弃。

如果通过，则使用MAC模块对MAC部分进行验证，如果是发送给本机的数据则留下，如果不是则丢弃。MAC是对以太网协议的实现，以太网的发送就是以广播机制发送给所有的局域网机器，如果是自己的则留下，否则丢弃。

通过mac检查过，拆下mac报头，将数据放到网卡缓冲区。

然后，网卡发起中断，CPU会到网卡缓冲区取出数据，然后交给IP模块

## IP
1. 检查IP报头，如果是自己的则留下，如果不是则转发【如果启用了路由功能】
2. 检查是否使用分包，是则合并包
3. 检查传输层协议字段，视情况发送给TCP、UDP或其他协议

## TCP
1. 检查SYN字段是否为1，是则表示这是一个发起连接的请求
2. 检查端口，首先看对应端口是否有正处于等待状态的套接字，如果没有则失败，有的话将数据给对应端口
3. 对应端口的连接套接字创建通信套接字，将连接发送给通信套接字，并将发送方信息写入套接字控制字段
4. 进行通信
5. 断开

回顾下3次握手：
1. 客户端发给服务端
2. 服务端响应客户端
3. 客户端响应服务端

服务端通信过程：
1. **将其分配给对应套接字**
2. 获取ACK、窗口大小等信息
3. 检查ACK，收下对应的包
4. 将包数据部分取出，会对应的应用数据合并，并放到缓冲区

回顾下断开的4次挥手
1. 服务端发起请求，表示不会再发送数据
2. 客户端接收，表示我知道了
3. 客户端数据发完了，发送信息说我不会再发消息给你了
4. 服务端彻底断开请求，发送响应说：我知道了，已彻底断开

## Socket
将数据取出，交给对应的应用程序