[TOC]

# `ret`
相当于`pop ip`

# `retf`
相当于
```
pop IP
pop CS
```

# `call`
1. 将当前`ip`或`cs`和`ip`推入栈中
2. 转移

## 指令格式
- `call 标号` 位移转移
- `call far ptr 标号` 标号战役【指定内存地址转移】
- `call 16位寄存器` call不能进行短转移
- `call word ptr 内存地址`
- `call dword ptr 内存地址`

# `call`和`ret`搭配使用
通过`call`和`ret`实现模块化程序设计，让多个相互联系、功能独立的子程序共同工作
- `call 子程序标号` 将当前`cs:ip`推入栈
- 执行子程序
- `ret`/`retf` 通过栈还原`cs:ip`

这样指令执行完子程序就可以回到原来的位置，顺序向下执行了。

# `mul`
0. 如果乘数是8位
1. 1个乘数默认在`AH`寄存器上
2. 另1个乘数可以是任意8位寄存器，或放在内存字节单元中
3. 结果放在`AX`寄存器

0. 如果乘数是16位
1. 1个乘数默认在`AX`寄存器上
2. 另1个乘数可以是任意16位寄存器，或放在内存字单元中
4. 结果高位放在`DX`，低位放在`AX`

# 参数和结果传递的问题
参数存储位置
- 寄存器
- 内存单元

## 寄存器冲突
和内存不同，寄存器是通用空间，所以子程序和主程序都会使用寄存器，寄存器被多方使用可能会出现冲突

对于寄存器的使用，我们期望
1. 子程序不必关心其他程序使用了哪些寄存器
2. 父程序不必关心其他程序使用了哪些寄存器
3. 不会发生寄存器冲突

解决方案是：
1. 进入程序时，将该程序会使用到的寄存器的值入栈
2. 执行程序
3. 结束程序时，从栈中将寄存器的值还原