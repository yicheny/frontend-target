[TOC]

# 标志寄存器`flag`
## 作用
1. 存储相关指令的某些执行结果
2. 为CPU执行相关指令提供行为依据
3. 控制CPU的相关工作方式

# 标志位
| 标志 | 简称 | 0 | 1 | 说明 |  
| --- | --- | --- | --- | --- |
| ZF | 置零 | 结果非0 | 结果为0 | 操作指令执行后结果是否为0 | 
| PF | 奇偶 | 结果偶数1 | 结果奇数1 | 指令执行后，1的个数奇偶 | 
| SF | 符号 | 无符号 | 有符号 | 标志是有符号数还是无符号数 |
| CF | 进/借位 | 无进/借 | 有进/借 | 【无符号数】加法是否进位，减法是否借位 | 
| OF | 溢出 | 不溢出 | 溢出 | 【有符号数】是否溢出 | 
| DF | 方向 | si、di递增 | si、di递减 | 控制每次操作后si、di的变化 | 

# 指令
| 指令 | 名称 | 说明 | 
| --- | --- | --- |
| adc | 进位加法 | A+B+CF |
| sbb | 借位减法 | A-B-CF | 
| cmp | 比较 | 比较两个值是否相等（相减操作，看结果是否为0）| 

# 比较转移指令
| 指令 | 含义 | 检测的标志位 | 说明 |
| --- | --- | --- | --- |
| je | 等于则转移 | ZF=1 | a-b=0 |
| jne | 不等于则转移 | ZF=0 | a-b!=0 |
| jb | 低于则转移 | CF=1 | a-b<0 需要借位 |
| jnb | 不低于则转移 | CF=0 | a-b>=0 不需要借位 | 
| ja | 高于则转移 | CF=0且ZF=0 | 不低于且不等于 |
| jna | 不高于则转移 | CF=1或ZF=1 | 低于或等于 | 

# 串传送指令
## `movsb`、`movsw`
`movsb`、`movsw`用于串传送，会使用`DF`标志。

`DF=1`，执行`movsb`：
```
((es)*16+(di)) = ((ds)*16+(si)) ;赋值
(si)=(si)-1
(di)=(di)-1
```

## `rep`
通常，串传送指令会配合`rep`指令，`rep movsb`相当于
```
s:  movsb
    loop s
```

## `cld`、`std`
- `cld`将`DF`设置为`0`
- `std`将`DF`设置为`1`

# `pushf`、`popf`
- `pushf` 用于将标志寄存器的值入栈
- `popf` 用于将栈数据送入标志寄存器

# 标志寄存器在`debug`中的表示
| 标志 | 值为1的标记 | 值为0的标记 | 
| --- | --- | --- | 
| OF | OV | NV |
| SF | NG | PL |
| ZF | ZR | NZ | 
| PF | PE | PO | 
| CF | CY | NC | 
| DF | DN | UP |

# 专题：为什么需要`CF`位？
> 和电路中的进位器有点像，通过进位器我们可以很方便的将两个8位加法器组成称16位加法器

我现在以一个简单的例子来说明，假设我们现在有2个寄存器，暂且称之为寄存器A和寄存器B，这两个寄存器可以保存2位的十进制信息【十进制我们最熟悉，以此举例，2进制或者16进制其实也一样】

不考虑进位器的情况下，我们可以进行10以内的加法，比如说`33+44=77`

现在，如果我们想通过这两个寄存器实现`77224488+11115566`，要怎么做呢？

只需要一个进位器，我们就可以实现这个需求，我们来演示下：
```
//1. 将77224488和11115566两位数字一组分组
77224488分组得到[77,22,44,88]
11115566分组得到[11,11,55,66]

//2. 对第一组进行相加
66+88+CF = 154+0 = 154 
取54保存，此时内存值54，CF变为1

//3. 对第二组进行相加
44+55+CF = 99+1 = 100
取00保存，此时内存值0054，CF变为1

//4. 对第三组进行相加
22+11+CF = 33+1 = 34
取34保存，此时内存值为340054，CF变为0

//5. 对第四组进行相加
77+11+CF = 88+0 = 88
取88保存，此时值为88340054，CF变为0

最终结果为88340054，实际那计算机验算后无误
```

到这里我们可以发现，只需要2个寄存器，1个进位器，我们可以实现超大数字的加法，不会收到寄存器大小限制