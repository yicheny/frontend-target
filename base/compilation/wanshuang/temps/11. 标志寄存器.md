
# OF
定义：溢出，进行**有符号**数运算时，超过机器所能表示的范围

举例：8位寄存器可以表示的范围是`-128~127`，那么针对以下运算：
```
mov al,100
add al,30 ;结果是130，会发生溢出
```

计算机中怎么确认存的是有符号数还是无符号数？

# adc
```
mov ax,2
mov bx,1
sub bx,ax ;发生借位，此时CF=1
adc ax,3 ;相当于(ax)+3+CF = 2+3+1 = 6
```

## 为什么需要`CF`位？
> 和电路中的进位器有点像，通过进位器我们可以很方便的将两个8位加法器组成称16位加法器

我现在以一个简单的例子来说明，假设我们现在有2个寄存器，暂且称之为寄存器A和寄存器B，这两个寄存器可以保存2位的十进制信息【十进制我们最熟悉，以此举例，2进制或者16进制其实也一样】

不考虑进位器的情况下，我们可以进行10以内的加法，比如说`33+44=77`

现在，如果我们想通过这两个寄存器实现`77224488+11115566`，要怎么做呢？

只需要一个进位器，我们就可以实现这个需求，我们来演示下：
```
//1. 将77224488和11115566两位数字一组分组
77224488分组得到[77,22,44,88]
11115566分组得到[11,11,55,66]

//2. 对第一组进行相加
66+88+CF = 154+0 = 154 
取54保存，此时内存值54，CF变为1

//3. 对第二组进行相加
44+55+CF = 99+1 = 100
取00保存，此时内存值0054，CF变为1

//4. 对第三组进行相加
22+11+CF = 33+1 = 34
取34保存，此时内存值为340054，CF变为0

//5. 对第四组进行相加
77+11+CF = 88+0 = 88
取88保存，此时值为88340054，CF变为0

最终结果为88340054，实际那计算机验算后无误
```

到这里我们可以发现，只需要2个寄存器，1个进位器，我们可以实现超大数字的加法，不必收到寄存器大小限制