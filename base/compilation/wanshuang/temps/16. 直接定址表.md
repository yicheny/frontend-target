[TOC]

本章讨论如何有效组织数据，以及相关编程技术

# 描述了单元长度的标号
我们一直使用标号来标记代码、数据、段的起始地址，比如
```
assume cs:code

code segment:
    a:db 1,2,3,4,5,6,7,8
    b:dw 0

start:  mov si,offset a
        mov bx,offset b
        mov cx,8
    s:  mov al,cs:[si]
        mov ah,0        ;将a标号的数据依次放到ax寄存器上
        add cs:[bx],ax  ;叠加到b标号内存地址上
        inc si
        loop s

        mov ax,4c00h
        int 21h

code ends
end start
```

这种方式的标号只能标识地址，而不能标识数据长度（即是单字节、单字、双字类型的数据）

我们可以使用另一种标记方式，不仅可以标识地址，还是标识数据长度，比如
```
assume cs:code

code segment:
    a db 1,2,3,4,5,6,7,8 ;注意，没有“:”了
    b dw 0 ;注意，没有“:”了

start:  mov si,0
        mov cx,8
    s:  mov al,a[si]
        mov ah,0        
        add b,ax  
        inc si
        loop s

        mov ax,4c00h
        int 21h

code ends
end start
```

注意看，形如`a db`这种形式的写法可以标识数据类型，同时标识地址

比如`a db`标识这里定义的数据都必须是`db`类型

这样我们可以使用更简洁的写法，比如：
```
mov ax,b
相当于 mov ax,cs:[8]

mov b,2
相当于 mov word ptr cs:[8],2

inc b
相当于 inc cs:[8],2

mov al,a[si]
相当于 mov al,cs:0[si]

mov al,a[3]
相当于 mov al,cs:0[3]
```

这种包含**单元长度**的标号，可以让我们以更简洁的方式访问内存中的数据，我们将这种标号叫做**数据标号**。

# 在其他段中使用数据标号
刚刚的代码是在代码段中定义数据，然而通常，我们应该在数据段定义数据，数据标号也可以在其他段中使用。

> 注意：形如`s:`这种形式的标号**只能在代码中使用**

1. 注意，如果想在代码段中，直接用数据标号访问数据，则需要使用伪指令`assume`将段号和段寄存器联系起来，
2. 否则编译器在编译的时候，无法确定标号的段地址在哪个寄存器中
3. 这种联系是编译器需要的，但是这不是说，我们用`assume`指令将段寄存器和某个段相联系，段寄存器就会真的存放该段的地址【只是编译器工作需要】，我们在程序中还是要对段寄存器进行设置

## 思考：为什么设置`assume`关联后，还是需要手动设置段寄存器？
实际上这是两件事
1. `assume`关联后，访问数据就知道将哪个寄存器作为段寄存器
2. 但是，`assume`并不会主动将段地址设置到段寄存器上

举个例子，
1. 通过`assume`将`data`段和`ds`寄存器关联
2. 如果访问`data`的标号`a`，CPU会直接去`ds`读取段地址
3. 但是，`ds`寄存器的地址不会自动设置为`data`的段地址，所以需要手动设置

# 将标号当作数据使用
我们可以将标号当作数据使用，此时，编译器将标号所表示的地址当作数据的值

```
data segment
    a db 1,2,3,4,5,6,7,8
    b dw 0
    c dw a,b ;c存储的是a,b的偏移地址，相当于 c dw offset a,offset b
    d dd a,b ;相当于 d dw offset a, seg a, offset b, seg b
data ends
```

# 直接定址表
可以依据数据，直接计算出所要找的元素的位置的表，我们称其为：直接定址表

直接定址表的目标一般有3个：
1. 【可读】为了算法的清晰和简洁
2. 【性能】为了加快运算速度
3. 【维护】为了程序易于扩充