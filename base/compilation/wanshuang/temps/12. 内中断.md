[TOC]

# 中断信息
CPU执行当前指令时，如果检测到某种特殊信息，CPU必须**立即**对这种信息进行处理。这种特殊信息就是中断信息，中断信息的意思就是接收到这种信息之后CPU必须要中断对当前程序的执行，优先处理这种特殊信息

中断信息可以来自CPU内部，也可以来自外部，本章主要介绍来自CPU内部的中断，简称内中断。

# 内中断
以下4种情况属于内中断：
1. 除法错误【比如溢出】
2. 单步执行
3. 执行int0指令
4. 执行int指令

这4种情况会产生4种不同的中断信息，CPU使用**中断类型码**标记中断信息类型。

中断类型码是字节型数据，所以最多可以表示256种不同类型的中断信息。

1. 除法错误，0
2. 单步执行，1
3. int0，4
3. int n，n

# 中断处理程序
CPU收到中断信息类型时，需要对中断信息进行处理，处理中断信息的程序被叫做**中断处理程序**

# 中断向量表
中断向量表是中断程序入口地址组成的列表，通过中断向量表可以找到对应的中断程序入口地址

8086CPU中，中断向量表被存放在0000:0000到0000:03E8这1000个内存单元中，这个存放区是**固定不可变**的

一个入口地址有2个字组成，高地址字存放段地址，低地址字存放偏移地址

# 中断过程
1. 程序异常，抛出中断类型码
2. 通过中断类型码从中断向量表中找到中断处理程序入口地址
3. 使用找到的入口地址设置CS和IP

以上是中断过程的主要流程，不过有一点需要注意：处理完中断之后程序需要回到原来的地址继续执行指令，所以需要将原来的CS和IP进行保存。

详细处理流程【8086】：
1. （从中断信息中）取得中断类型码
2. 标志寄存器的值入栈（在中断过程中会改变标志寄存器的值，所以需要先保存在栈中）
3. 设置标志寄存器的TF、IF为0（TF为0是为了避免无限循环，IF？）
4. CS入栈
5. IP入栈
6. 从内存地址为 `中断类型码*4` 读取入口程序偏移地址设置 IP
7. 从内存地址为 `中断类型码*4+2` 读取入口程序段地址设置 CS

代码描述：
1. 取得中断类型码 N
2. pushf
3. TF=0，IF=0
4. push CS
5. push IP
6. (IP)=(N*4)
7. (CS)=(N*4+2)

# 中断处理程序
1. 保存使用的寄存器值
2. 处理中断
3. 恢复使用的寄存器值
4. 使用iret

iret相当于
1. pop IP
2. pop CS
3. pupf

# 除法错误导致的中断
比如说我们用`1000h`除以`1`得到的结果是`1000h`，16位除以8位，我们预期结果是8位，然而结果是16位，那么就会造成溢出。

此时会抛出中断信息，CPU从中断信息中获取中断类型码，然后执行中断处理程序。

默认中断处理程序会输出“Divide Overflow”，然后返回操作系统

## 自定义中断程序
1. 编写自定义程序
2. 将程序放到内存中
3. 将中断向量表中中断码对应的入口地址变更

## 安装自定义中断程序
```asm
assume cs:code

code segment

start:  mov ax,cs
        mov ds,ax
        mov si,offset do0 ; ds:si指向源程序地址

        mov ax,0
        mov es,ax
        mov si,200h ；es:si是源程序在内存中存储的目标地址

        mov cx,do0代码长度 ;cx是代码长度，目前是手动计算
        cld ;传输方向为正
        rep movsb

        ;设置中断向量表
        mov ax,0
        mov es,ax
        mov word ptr es:[0*4],200h ;偏移地址
        mov word ptr es:[0*4+2],0  ;段地址     

        mov ax,4c00h
        int 21h
        
do0:    显示字符串"overflow!"
        mov ax,4c00h
        int 21h

code ends
end start
```

### 动态计算代码长度
```
start:  ...
        mov cx,offset do0end - offset do0 ;“-”是编译器识别的运算符号，用于两个常数的减法
        ...

d0:     ...
do0end  nop
```

# 单步中断
CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生但不中断。

过程：
1. 从信息中取得中断类型码1
2. 标志寄存器入栈，TF、IF设置为0
3. CS、IP入栈
4. (IP)=(1*4)，(CS)=(1*4*2)

## 为什么提供单步中断
如果没有单步中断能力，那么CPU一通电就会从预设地址一直执行下去，任何程序都不能控制它在执行完一条指令后停止。

## 应用
`DEBUG`的`T`指令，可以在执行一条指令后，返回到`DEBUG`主程序中，从而可以通过其他执行查看寄存器的状态。

# 响应中断的特殊情况
1. 一般情况下，CPU执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程
2. 有些情况下，CPU在执行完当前指令后，即便发生中断，也不会响应

举例：
1. 在执行完ss寄存器传送数据的指令后，即使发生中断，CPU也不会响应
2. 原因是：`ss:sp`联合指向栈顶，对它们的设置要**连续**完成
3. 如果执行完设置`ss`的指令后，CPU响应中断 引发中断过程，要在栈中压入标志寄存器、CS和IP的值
4. 而ss改变，sp并未改变，所以`ss:sp`指向的不是正确的栈顶，这会造成错误
5. 因此，CPU在执行完设置`ss`的指令后，不会响应中断
6. 这给连续设置ss和sp指向正确的栈顶提供了时机

代码：
```
;应该这么写
mov ax,1000h
mov ss,ax
mov sp,0

;不要这么写
mov ax,1000h
mov ss,ax
mov ax,0
mov sp,0
```