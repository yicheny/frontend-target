[TOC]

# 编译器的结构
1. 编译器可以将源程序**映射**为语义上等价的目标程序
2. 映射部分由两部分组成：分析和综合

分析部分
1. 把源程序分解成多个要素，并在这些要素之上添加语法结构
2. 使用这个结构来创建源程序的一个中间表示
3. 如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它必须提供有用的信息，使得用户可以按此进行改正
4. 分析部分还会收集有关源程序的信息，并把信息存放在一个叫做**符号表**的数据结构中
5. 符号表将和中间表示一起传送给综合部分

综合部分
1. 根据中间表示和符号表构建用户期待的目标程序

步骤(phase)
1. 编译过程顺序的执行了一组步骤
2. 每个步骤将程序的一种表示方式转换为另一种表示方式
3. 实践中，多个步骤可能被组合在一起
4. 这些被组合在一起的步骤之间的中间表示不需要被明确构建出来
5. 存放整个源程序的信息的符号表可由编译器的各个步骤使用

## 词法分析
1. 编译器的第1个步骤叫做**词法分析**或**扫描**
2. 词法分析器读入组成源程序的字符流
3. 并且将它们组织成有意义的词素序列
4. 对于每个词素，词法分析器产生词法单元作为输出：`<token-name,attribute-value>`
5. 这个词法单元被传送给下一个步骤，即语法分析步骤

`<token-name,attribute-value>`
1. `token-name`是一个由语法分析使用的抽象符号
2. `attribute-value`指向指向符号表中关于这个词法单元的条目，符号表条目信息会被语义分析和代码生成步骤使用

举例：`position = initial + rate * 60`
1. `position`是一个词素，被映射成词法单元`<id,1>`
   1. `id`是标识符的抽象符号
   2. `1`指向符号表中对应的条目
   3. 一个标识符对应的符号表条目存放该标识符有关的信息，比如它的名字和类型
2. 赋值符号`=`是一个词素，被映射成词法单元`<=>`
   1. 因为这个词法单元不需要属性值，所以我们省略了第二个分量
   2. 也可以使用`assign`这样的抽象字符作为词法单元的名字
   3. 但是为了标记上的方便，我们使用赋值符号本身作为词法单元的名字
3. `initial`是一个词素，被映射成词法单元`<id,2>`
4. `+`是一个词素，被映射成`<+>`
5. `rate`是一个词素，被映射成词法单元`<id,3>`
6. `*`是一个词素，被映射成词法单元`<*>`
7. `60`是一个词素，被映射成`<number,4>`

> 分隔词素的空格会被词法分析器忽略掉

被词法分析后的赋值语句，会转变成如下词法单元序列：
```
<id,1> <=> <id,2> <+> <id,3> <*> <number,4>
```

## 语法分析
1. 编译器的第2个步骤称为**语法分析**或**解析**
2. 语法分析器使用 词法分析器生成的 各个词法单元的 第一个分量 来创建树形的中间表示
3. 该中间表示给出了 词法分析产生的 词法单元流的语法结构
4. 一个常用的表示方法是语法树
   1. 树中的每个内部节点表示一个运算
   2. 而该节点的字节点表示该运算的分量

## 语义分析
1. 语义分析器使用 语法树和符号表中的信息 来检查源程序语义 是否和语言定义的语义一致
2. 它同时也收集类型信息，并把这些信息存放到符号表或语法树中，以便在代码生成时使用
3. 语义分析器会进行类型检查，检查每个运算符是否有匹配的运算分量
4. 语言可能允许某些类型转换，这被称为自动类型转换

## 中间代码生成
1. 把一个源程序编译成目标代码的过程中，可能构造出多个中间表示
2. 语法树是中间表示的一种
3. 在语法和语义分析完成后，很多编译器会生成一种低级的或类语言的中间表示
4. 该中间表示应该具有两个性质
   1. 易于生成
   2. 可以轻松翻译成目标机器上的语言

## 代码优化
机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码：
1. 更快
2. 更短
3. 能耗更低

## 代码生成
1. 代码生成器以源程序的中间表示作为输入，并将其映射为目标语言
2. 如果目标语言是机器代码，那么就必须为程序使用的每个变量选择寄存器或内存位置
3. 然后，中间指令被编译成能够完成任务的机器指令序列

> 代码生成的一个至关重要的方面是合理分配寄存器以放置变量的值