[TOC]

# 使用表驱动法的两个问题
1. 怎么从表中查询条目？
    1. 有一些数据可以用来直接访问表，比如如果希望数据按月分类，可以建月份表
    2. 另一些数据难以直接用于访问表，比如说我们想按身高分类，但是身高划分粒度是`0.01`，而且很难确定最高值。此时我们可以采用更复杂的方案
        1. 直接访问
        2. 索引访问
        3. 阶梯访问
2. 应该在表里存什么？
    1. 数据
    2. 函数

# 直接访问
比如说我们现在想获取每个月的天数，如果使用逻辑处理，我举3种常见的做法：

唯一的优点大概是排版比较清晰吧，写法1：
```js
if(month === 1) date = 31;
else if(month === 2) date = 28;
else if(month === 3) date = 31;
else if(month === 4) date = 30;
else if(month === 5) date = 31;
else if(month === 6) date = 30;
else if(month === 7) date = 31;
else if(month === 8) date = 31;
else if(month === 9) date = 30;
else if(month === 10) date = 31;
else if(month === 11) date = 30;
else if(month === 12) date = 31;
```

写法2，这种写法整合了条件，消除重复逻辑，将原本12份代码段分成了3份，实际给人的感觉是更恶心了，因为这里逻辑处理的部分不复杂，如果这里`date=31`是一个繁杂的代码处理【在实际开发中是很有可能的】，那么这种写法的优势就能体现了，因为这样将分离的变化聚合到一处，修改会变得容易。
```js
//这里我为什么不使用includes
//1. 使用includes其实还是使用表格驱动法的一些特性，但这种做法是不完全的表格驱动法，存在很多问题，我下面会再写一个includes版本的
//2. includes是个语法糖，更纯粹的写法更好的逻辑面临的问题

if(month === 2) date = 28;
else if(month === 1 || month === 3 ||
    month === 5 || month === 7 ||
    month === 8 || month === 10 ||
    month === 12 ){
        date = 31
}
else if(month === 4 || month === 6 || 
    month === 9 || month === 11){
        date = 30
}
```

写法3，其实是2的变种，逻辑基本一致，使用了`includes`语法糖，在2的基础上进一步简洁了代码
```js
if(month === 2) date = 28;
else if([1,3,5,7,8,10,12].includes(month)) date = 31
else if([4,6,9,11].includes(month)) date = 30
```
写法上看起来好了很多，我们综合评价下：
1. 代码简洁度提升
2. 维护性有所提升
3. 性能降低，从代码执行角度考虑，通过循环执行并不能减少判断次数，实际上因为加了循环速度会变慢，而且进一步考虑`includes`也是一层栈消耗的

我个人的角度来看写法2和3在日常开发中都大量出现，很容易遇到。

我们来看一下使用直接定址表的写法：
```js
date = [31,28,31,30,31,30,31,31,30,31,30,31][month-1];
```
只有一行，而且性能也是超强的`O(1)`，我们综合评价下这种写法：
1. 代码简洁度进一步提升
2. 维护性进一步提升
3. 性能极大提升

## 关于性能
这里稍微说明下为什么使用数组索引的方式性能要远远强于其他几种写法。

其实主要是三种检测方式：
1. 判断
2. 循环+判断
3. 数组索引

首先是判断，写法1和2最差情况下是执行了12次判断，最理想是1次判断，如果用大O表示法是`O(n)`【如果不用`else if`使用`if`理论上性能会下降1倍】

而写法3，除了12次判断，还包括循环的性能消耗，假设判断的消耗是x，而循环的消耗是y【y必大于0】，易得`x+y > x`，所以无论如何，写法3性能都是最差的

然后是数组索引，它的速度为什么是`O(1)`呢？
1. 首先我们知道数据存放在内存的内存单元中，每个内存单元都有自己的内存地址
2. 我们通过内存地址去内存单元取数据
3. 数组项通过`基准地址+偏移`计算获取到数据内存地址
    1. 假设有一个数组`[11,12,13,14]`，数组数据被连续的放置在内存空间
    2. 假设数组基准地址是`100`，数组项的内存地址就是`100,101,102,103`
    3. 假设现在得到索引`2`，通过`基准地址+索引`即可快速得到内存地址`102`
    4. 通过内存地址取值`13`

简单来说就是数组通过索引取值不需要判断，只会进行1次内存地址的计算，得到内存地址后，直接取值即可，所以速度为`O(1)`