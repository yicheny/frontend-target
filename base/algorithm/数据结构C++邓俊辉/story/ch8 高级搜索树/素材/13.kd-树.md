#　范围查找问题
很多实际问题都是范围查找问题，比如说从学生数据库中查询2001-2004级的学生，查询身高在160-180之间的学生。

这种问题统称为一维查询问题。

## 蛮力算法
最直接最简单的做法就是遍历，从中选取符合条件的数据。

代价是
1. 时间复杂度是`O(n)`，对于大数据而言效率难以让人满意。
2. 空间复杂度也是`O(n)`，大数据会存储在外存中，那么这种做法会频繁进行`I/O`操作，也会进一步降低速度，而且影响程度是很大的。
3. 实际需要的数据对于整个数据而言只是极小的一段，真正符合条件的数据量为r，整体数据量为n，此时如果以`O(n)`作为界限并不合理

## 预处理
实际开发中，查询区域的特点是很显著的，我们可以针对原始数据进行预处理，提前将其组织成某种适当的数据结构，这样可以进一步提高之后的查询效率。

## 有序向量
最简单的预处理方案是将其组织成有序向量。【花费时间`O(nlogn)`】

对于整体数据量为`n`，查找区间`[x1,x2]`的数据（数据量为`r`），时间复杂度是`O(logn + r)`

这里可以看见，影响时间复杂度最大的因素是输出数据量，这种时间复杂度的算法，称作输出敏感型算法。

## 二维查找
真正的难点和挑战是，在实际应用中，往往需要对数据进行多个维度的范围查找。

以学生数据库为例，查询2001-2004级且身高在160-180之间的学生。

针对某一固定点集的范围查询，其查询范围可描述为：`R = [x1,x2] * [y1,y2]`

遗憾的是，上述有序向量的方式不能直接推广至二维及更高维场景，故此我们需要寻找其他方案

## 平衡二叉搜索树
![](https://pic.imgdb.cn/item/624ab7be239250f7c5441a43.jpg)

同样是二分查找。

这是另一份实现：

![](https://pic.imgdb.cn/item/624ab8b9239250f7c5464c4c.jpg)

相比于第一份实现：
1. 使用的内存空间增大一倍
2. 树高+1
3. 查询速度提升【每个节点只需要判断一次】

> 对应二分算法实现版本3

现在我们来看它是怎么查询范围的。

假设我们想要查询`[1,23]`， 
1. 【查找界限节点】收束于`3`、`24`
2. 【查找LCA】`lca(3,24) = 15`
3. 【从LCA开始，重走通向节点节点的路线】
   1. `path(3) = {3,4,7,9,12,14,15}`
   2. `path(24) = {17,20,22}`

# kd-树

# 名词
- **LCA**(lowest common ancestor)，最低共同祖先
