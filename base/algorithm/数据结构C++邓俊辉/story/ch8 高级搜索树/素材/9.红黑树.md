
# 问题
各种搜索树的特点：
1. AVL，目前效率最好的树，缺点是需要动态调整结构和记录平衡因子，实现较为复杂，然后是在删除是可能有`O(logn)`级别的结构调整
2. 伸展树，实现简单，分摊复杂度低，适合数据频繁访问的场景，缺点是最坏复杂度是`O(n)`，难以应用在需要保证稳定性的场景
3. 多路树，适合大数据存储在外存的场景，然而在一般场景下表现不如其他搜索树

红黑树主要是对AVL的改进，红黑树可保证插入或删除仅涉及常数级别的调整。在最坏场景下，依旧需要对`O(logn)`个节点染色，然而分摊意义下依旧是常数级别

为此需要在AVL的“适度平衡”要求下，进一步降低标准：任一节点的左右子树高度相差不得超过2倍

# 定义
满足以下定义的搜索二叉树即为红黑树
1. 树根始终为黑色
2. 外部节点均为黑色
3. 其余节点若为红色，则其孩子节点必为黑色
4. 从任一外部节点到根节点的沿途，黑节点的数目相等 

1、2我认为很容易理解和实现。

麻烦的是3、4怎么实现？

# 与4阶B-树转换
转换原则：
1. 自顶而下逐层考查红黑树各节点
2. 每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点（必黑）水平对齐，二者之间的联边则相应地调整为横向
3. 转换之后，横向边在黑父节点或左或右【由红黑树的条件(3)，同向者彼此不会相邻】
4. 沿水平方向黑父节点相邻的红边至多两条（向左、右各一条）
5. 此时，1个黑节点 加 0~2个红边组成了4阶B-树的一个大节点

# 基础场景图例
所有场景都可以划分为4种基础场景，我们分别看一下：

# 名词：
- 除去根节点本身，沿途所经黑节点的总数称作该节点的**黑深度**（black depth）
- 除去（黑色）外部节点，沿途所经黑节点的总数称作该节点的**黑高度**（black height）。