
# ADT
```c++
#include "../BST/BST.h" 

template <typename T> class RedBlack : public BST<T> { 
protected: 
   void solveDoubleRed ( BinNodePosi(T) x ); //双红修正 
   void solveDoubleBlack ( BinNodePosi(T) x ); //双黑修正 
   int updateHeight ( BinNodePosi(T) x );
public: 
   BinNodePosi(T) insert ( const T& e )
   bool remove ( const T& e ); 
 // BST::search()等其余接口可直接沿用 
 };
```

# 工具方法
> 注意：以下高度不是常规树高，特指红黑树的黑高度
```c++
//节点不存在也视作黑节点
#define IsBlack(p) ( ! (p) || ( RB_BLACK == (p)->color ) ) 
//不是黑的就是红的
#define IsRed(p) ( ! IsBlack(p) )

//是否需要更新黑高度
//1. 左右高度不相等
//2. 作为红孩子，黑高度与其孩子不相等
//3. 作为黑孩子，黑高度不等于孩子的黑高度+1
#define BlackHeightUpdated(x) ( 
    //如果x.lc、x.rc高度相等
    //伪代码：x.height == (isRed ? x.lc.height : (x.lc.height + 1))
   ( stature( (x).lc ) == stature( (x).rc ) ) && \ 
   ( (x).height == ( IsRed(& x) ? stature( (x).lc ) : stature( (x).lc ) + 1 ) ) \ 
)

//更新节点高度 
template <typename T> int RedBlack<T>::updateHeight ( BinNodePosi(T) x ) {
   x->height = max ( stature ( x->lc ), stature ( x->rc ) ); 
   return IsBlack ( x ) ? x->height++ : x->height; //如果当前节点为黑，则计入黑高度
}
```

# `insert`
插入思路：
1. 首先通过search查找，检查其返回的位置，如果不存在已有节点，则创建新节点x，并将其染成红色【除非此时全树只有一个节点】
2. 对照红黑树4项条件，唯有第3条未必满足——即x的父亲也可能是红色
   1. 树根为黑【确定】
   2. *外部节点为黑【确定】——实际上可能被插入的情况只有两种，原来的`_hot`部分只可能有`0-1`个孩子
      1. `0`孩子，新节点x可以向上跑两层（作为原父节点的父节点），其平衡和顺序可保证
      2. `1`孩子，将新节点x和原父节点位置互换，其平衡性顺序可保证
      3. 经以上调整，其`x`必存在兄弟和孩子节点
   3. 其余节点为红，则其孩子必为黑【难以保证】
   4. 任意外部节点到根节点，黑高度相等【确定】
3. 若存在双红问题，则调用`solveDoubleRed`修复
```c++
template <typename T> BinNodePosi(T) RedBlack<T>::insert ( const T& e ) { 
   BinNodePosi(T) & x = search ( e ); if ( x ) return x;
   x = new BinNode<T> ( e, _hot, NULL, NULL, -1 ); _size++;  
   solveDoubleRed ( x ); return x ? x : _hot->parent;
}
```

# 名词
-   因新节点引入，导致父子节点同为红色的情况，称为**双红**（double red）