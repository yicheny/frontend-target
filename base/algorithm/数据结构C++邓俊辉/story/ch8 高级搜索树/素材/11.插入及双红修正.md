# `insert`
插入思路：
1. 首先通过search查找，检查其返回的位置，如果不存在已有节点，则创建新节点x，并将其染成红色【除非此时全树只有一个节点】
2. 对照红黑树4项条件，唯有第3条未必满足——即x的父亲也可能是红色
    1. 树根为黑【确定】
    2. *外部节点为黑【确定】——实际上可能被插入的情况只有两种，原来的`_hot`部分只可能有`0-1`个孩子
        1. `0`孩子，新节点x可以向上跑两层（作为原父节点的父节点），其平衡和顺序可保证
        2. `1`孩子，将新节点x和原父节点位置互换，其平衡性顺序可保证
        3. 经以上调整，其`x`必存在兄弟和孩子节点
            - 孩子节点必为黑节点【确定】
            - 兄弟节点必为黑节点【如何证明？】
    3. 其余节点为红，则其孩子必为黑【难以保证】
    4. 任意外部节点到根节点，黑高度相等【确定】
3. 若存在双红问题，则调用`solveDoubleRed`修复
```c++
template <typename T> BinNodePosi(T) RedBlack<T>::insert ( const T& e ) { 
   BinNodePosi(T) & x = search ( e ); if ( x ) return x;
   x = new BinNode<T> ( e, _hot, NULL, NULL, -1 ); _size++;  
   solveDoubleRed ( x ); return x ? x : _hot->parent;
}
```

# 双红修正

# 名词
-   因新节点引入，导致父子节点同为红色的情况，称为**双红**（double red）