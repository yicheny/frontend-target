
# 问题
如纯粹的按二叉搜索树的定义进行插入，那么树高很难达到理想情况。

搜索速度和树高成正比，理想树高是`log2n`。

实际上不做控制，那么树高会在`log2n`~`n`之间，假设所有情况出现的可能性相同，那么平均树高是`n的平方根`，最差是`n`级别。

为此我们需要优化插入逻辑，使得每次调整后树高相对保持在一个理想高度。

# 优化方案
二叉搜索树有一个特性：同一个遍历顺序可能存在不同的结构。

故此，我们可以在保持遍历顺序不变的情况下降低树高。

但是同样的，我们不希望对树高的调整过于麻烦，比如花费`O(n)`的时间进行调整，这对我们是得不偿失的。

## 局部性
为此，需要保证局部性：
1. 经过单次动态修改操作后，至多只有`O(1)`处局部不再满足限制条件
2. 总可在`O(logn)`时间内，使这`O(1)`处局部（以至全树）重新满足限制条件

# 修复手段
最基本的修复手段是局部的旋转调整，以下介绍`zig`、`zag`两种旋转方式。

效率上两个操作都是常数级别的。