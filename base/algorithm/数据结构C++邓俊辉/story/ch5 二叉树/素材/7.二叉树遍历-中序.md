# 中序
先遍历左子树，从最左侧叶节点开始进行访问，然后遍历右子树

## 递归实现
```c++
template <typename T, typename VST> 
void travIn_R ( BinNodePosi(T) x, VST& visit ) { 
   if ( !x ) return; 
   travIn_R ( x->lc, visit ); 
   visit ( x->data ); 
   travIn_R ( x->rc, visit ); 
} 
```

## 迭代实现1
描述下思路：
1. 当前节点有右孩子，则转入右子树，沿该子树的最左侧通路到达最左侧叶节点
2. 当前节点没有右孩子则向上寻找最低祖先
    1. 如果有右子树，执行步骤1
    2. 没有则继续向上，直到没有祖先节点为止

将需要访问的节点推入栈中，访问时依次弹出。

```c++
template <typename T> 
static void goAlongLeftBranch ( BinNodePosi(T) x, Stack<BinNodePosi(T)>& S ) { 
   while ( x ) { S.push ( x ); x = x->lc; } 
} 

template <typename T, typename VST> 
void travIn_I1 ( BinNodePosi(T) x, VST& visit ) { 
   Stack<BinNodePosi(T)> S;
   while ( true ) { 
       goAlongLeftBranch ( x, S ); 
       if ( S.empty() ) break;
       x = S.pop(); visit ( x->data ); 
       x = x->rc; 
    } 
 } 
```

## 迭代实现2
和迭代1的思路是一样的，只是换一种写法，为迭代3做准备。
```c++
template <typename T, typename VST> 
void travIn_I2 ( BinNodePosi(T) x, VST& visit ) { 
   Stack<BinNodePosi(T)> S;
   while ( true ) 
      if ( x ) { 
         S.push ( x );
         x = x->lc; 
      } else if ( !S.empty() ) { 
         x = S.pop();
         visit ( x->data );
         x = x->rc;
       } else 
          break; 
 } 
```

## 迭代实现3
以上迭代实现都使用了辅助栈，虽然对时间复杂度没有影响，但是所需辅助空间会线性正比于二叉树高度，最坏情况下与节点总数相同。

迭代3实现，不再使用任何结构体，其空间复杂度为`O(1)`，不过因为需要反复调用`succ()`，时间效率会有所降低。

> 此实现属于**就地算法**，即基本上不需要借助额外的数据结构就能对输入的数据进行变换的算法。

我们以中序遍历的约束实现`succ()`。

再次描述下思路：
1. 当前节点有右孩子，则转入右子树，沿该子树的最左侧通路到达最左侧叶节点
2. 当前节点没有右孩子则向上寻找最低祖先
1. 如果有右子树，执行步骤1
2. 没有则继续向上，直到没有祖先节点为止

首先实现`succ()`
```c++
template <typename T> 
BinNodePosi(T) BinNode<T>::succ() { 
   BinNodePosi(T) s = this;
   if ( rc ) { 
      s = rc;
      while ( HasLChild ( *s ) ) s = s->lc;
   } else {
      while ( IsRChild ( *s ) ) s = s->parent;
      s = s->parent; 
   } 
    return s; 
 } 
```

在实现`succ()`的基础上，描述下迭代的思路：
1. 从当前节点左子树深入，直到最左侧节点
2. 从最左侧节点向上，访问节点
    1. 如果有右子树，则进入右子树，执行步骤1【深入左子树】
    2. 如果没有右子树，继续向上，当没有后继节点时，退出迭代

迭代实现：
```c++
template <typename T, typename VST> 
void travIn_I3 ( BinNodePosi(T) x, VST& visit ) { 
   bool backtrack = false;//上一步是否回溯--这里回溯的意思相当于从上向下遍历，非回溯则是从下向上，此时可以进行访问
   while ( true ) 
      if ( !backtrack && HasLChild ( *x ) ) //有左子树且不是回溯
         x = x->lc; //深入左子树
      else {  
        visit ( x->data ); //访问当前节点
        if ( HasRChild ( *x ) ) { //有非空右子树
            x = x->rc; //转向右子树
            backtrack = false; //关闭回溯标识
         } else { 
            if ( ! ( x = x->succ() ) ) break; //回溯 --如果s->succ()为null，则终止迭代
            backtrack = true; //开启回溯标识
         } 
      } 
} 
```

# 资料
- [wiki-就地算法](https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)