# 后序
## 递归实现
```c++
template <typename T, typename VST>
void travPost_R ( BinNodePosi(T) x, VST& visit ) { 
   if ( !x ) return; 
   travPost_R ( x->lc, visit ); 
   travPost_R ( x->rc, visit ); 
   visit ( x->data ); 
} 
```

## 迭代实现
后序遍历是自底而上的，思路如下：
0. 将其分解为若干个片段
1. 访问当前节点
2. 遍历其右兄弟（若存在）为根的子树
3. 向上回溯至父节点（若存在）转入下一片段

![](https://pic.imgdb.cn/item/62258f535baa1a80abebd214.jpg)

```c++
template <typename T> 
static void gotoHLVFL ( Stack<BinNodePosi(T)>& S ) {
   while ( BinNodePosi(T) x = S.top() ) 
      if ( HasLChild ( *x ) ) { 
         if ( HasRChild ( *x ) ) S.push ( x->rc );
         S.push ( x->lc );
      } else 
         S.push ( x->rc ); 
   S.pop();  
 } 
  
 template <typename T, typename VST> 
 void travPost_I ( BinNodePosi(T) x, VST& visit ) { 
    Stack<BinNodePosi(T)> S; 
    if ( x ) S.push ( x ); 
    while ( !S.empty() ) { 
      if ( S.top() != x->parent ) //如果不是父节点，则必为左兄弟节点
         gotoHLVFL ( S );  //以左兄弟节点为根，遍历至HLVFL
      x = S.pop(); visit ( x->data ); //如果栈顶节点是父节点，则弹出依次访问【说明已经到底，没有其他子树需要进入】
   } 
}
```