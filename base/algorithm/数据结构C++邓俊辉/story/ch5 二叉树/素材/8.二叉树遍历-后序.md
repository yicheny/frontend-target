# 后序
## 递归实现
```c++
template <typename T, typename VST>
void travPost_R ( BinNodePosi(T) x, VST& visit ) { 
   if ( !x ) return; 
   travPost_R ( x->lc, visit ); 
   travPost_R ( x->rc, visit ); 
   visit ( x->data ); 
} 
```

## 迭代实现
![](https://pic.imgdb.cn/item/62258f535baa1a80abebd214.jpg)

观察上面的遍历图，可以发现规则是：
1. 如果有左节点
   1. 判断是否有右节点，有先推右
   2. 推左节点
2. 没有左节点，则推右
   1. 如果有，则继续深入右侧【执行步骤1】
   2. 如果没有，是空节点，推入
3. 如果栈顶为空节点，则弹出，并继续弹出，拿到栈顶节点
   1. 【停止条件】如果栈顶节点为当前节点的父节点，则证明到达终点，依次弹出访问即可
   2. 否则，栈顶节点必为父节点的左兄弟，以此节点为基点，执行步骤1、2

```c++
template <typename T> 
static void gotoHLVFL ( Stack<BinNodePosi(T)>& S ) {
   while ( BinNodePosi(T) x = S.top() ) 
      if ( HasLChild ( *x ) ) { 
         if ( HasRChild ( *x ) ) S.push ( x->rc );
         S.push ( x->lc );
      } else 
         S.push ( x->rc ); 
   S.pop();  
 } 
  
 template <typename T, typename VST> 
 void travPost_I ( BinNodePosi(T) x, VST& visit ) { 
    Stack<BinNodePosi(T)> S; 
    if ( x ) S.push ( x ); 
    while ( !S.empty() ) { 
      if ( S.top() != x->parent ) //如果不是父节点，则必为左兄弟节点
         gotoHLVFL ( S );  //以左兄弟节点为根，遍历至HLVFL
      x = S.pop(); visit ( x->data ); //如果栈顶节点是父节点，则弹出依次访问【说明已经到底，没有其他子树需要进入】
   } 
}
```