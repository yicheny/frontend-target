
# ADT 
- 属性
  - `_size`
  - `_root`
- 方法
  - 构造方法
  - 析构方法
  - `updateHeight()` 更新节点高度
  - `updateHeightAbove()` 更新节点及祖先高度
  - `size()`
  - `empty()`
  - `root()`
  - `insertAsRoot()` 插入根节点
  - `insertAsLC()`
  - `insertAsRC()`
  - `attachAsLC()` 接入左子树
  - `attachAsRC()`
  -` remove()` 移除子树，返回移除的子树规模
  - `secede()` 移除子树，返回移除的子树
  - `travLevel()` 层次遍历
  - `travPre()` 先序遍历
  - `travIn()` 中序遍历
  - `travOut()` 后序遍历
  - 判等器`==`
  - 判等器`<`
  
## 状态查询
`size()`、`empty()`、`root()`只是简单的状态查询，不展示具体实现

## 高度更新
首先是`updateHeight`，针对单个节点做更新：
```c++
template <typename T> int BinTree<T>::updateHeight ( BinNodePosi(T) x ){ 
    return x->height = 1 + max ( stature ( x->lc ),stature ( x->rc ) ); 
} 
```
逻辑很简单，就是从两个孩子中选取高度最大的一个，并在其基础上+1.

然后是`updateHeightAbove`，因为某个插入节点后，所有祖先元素高度都会受到影响，代码如下：
```c++
 template <typename T> void BinTree<T>::updateHeightAbove ( BinNodePosi(T) x ){ 
    while ( x ) {
        updateHeight ( x ); 
        x = x->parent; 
    } 
} 
```

## 插入
插入主要涉及三部分：
1. size更新
2. height更新
3. 插入节点

`insertAsRoot`是最简单的，实现如下：
```c++
template <typename T> BinNodePosi(T) BinTree<T>::insertAsRoot ( T const& e ){
    _size = 1;
    return _root = new BinNode<T> ( e ); 
} 
```

然后是`insertAsLChild`，实现如下：
```c++
template <typename T> BinNodePosi(T) BinTree<T>::insertAsLC ( BinNodePosi(T) x, T const& e ){
    _size++; 
    x->insertAsLC ( e ); 
    updateHeightAbove ( x ); 
    return x->lc; 
} 
```

`insertAsRChild`实现基本相同，不再展示。