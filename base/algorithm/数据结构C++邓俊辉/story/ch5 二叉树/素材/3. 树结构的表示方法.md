以下均以多叉树为前提。

二叉树实例：

![](https://pic.imgdb.cn/item/6229c5575baa1a80ab183f26.jpg)

# 方式1 记录父节点位置
思路描述
1. 将所有节点都放到向量或列表中
2. 其中每个元素保存
   1. 自身信息
   2. 父节点的秩或位置【根节点的父节点可设置为-1或NULL】

保存信息如下：   

| 地址  | 数据 | 父节点位置 |
|---|---| --- |
| 0   | R | -1 |
| 1   | A | 0 |
| 2   | B | 0 |
| 3   | C | 0 |
| 4   | D | 1 |
| 5   | E | 1 |
| 6   | F | 3 |
| 7   | G | 6 |
| 8   | H | 6 |
| 9   | K | 6 |

评价下这种保存的优势：
1. 查询任一节点的父节点，速度都是`O(1)`

# 方式2 记录子节点线性表
思路描述
1. 将所有节点放到列表或向量中
2. 其中每个元素保存
   1. 自身信息
   2. 子节点组成的向量或列表

基本思路和方法1类似，只是将保存的信息由父节点改成子节点。

保存信息如下：

| 地址  | 数据 | 子节点列表   |
|---|---|---------|
| 0   | R | 1->2->3 |
| 1   | A | 4->5    |
| 2   | B | ^       |
| 3   | C | 6       |
| 4   | D | ^       |
| 5   | E | ^       |
| 6   | F | 7->8->9 |
| 7   | G | ^       |
| 8   | H | ^       |
| 9   | K | ^       |

评价下这种方式的优势：
1. 对于有x个孩子的节点而言，可在`O(x+1)`时间内列出所有孩子

# 方式3 记录父节点+子节点
可以看到：
1. 方式1父节点查询快速
2. 方式2子节点查询快速

我们可以同时保存两种信息以兼顾优势。

| 地址  | 数据 | 父节点 | 子节点  |
|--- | ---| --- |--- |
| 0   | R | -1 | 1->2->3 |
| 1   | A | 0 | 4->5    |
| 2   | B | 0 | ^       |
| 3   | C | 0 | 6       |
| 4   | D | 1 | ^       |
| 5   | E | 1 | ^       |
| 6   | F | 3 | 7->8->9 |
| 7   | G | 6 | ^       |
| 8   | H | 6 | ^       |
| 9   | K | 6 | ^       |

# 问题：难以兼顾修改和查询
想象一下，如果我们对线性表进行插入或删除操作，会影响到大量节点。

向量自不必提，位置一旦变化，涉及到的父子节点地址就错乱了。（主要是删除任意一个节点，其他节点位置也会变化，这个就太坑了，根本不能接受）

那么如果使用列表存储信息呢？使用列表删除或插入节点不会影响其他节点的地址，只需要处理与之相关的父子节点。【然而这个因为多叉树的性质也成为了问题，下一节会说】

一个重要问题在于查询，如果使用列表，那么查询的优势不复存在。

列表对于频繁的插入和删除确实友好，但是查询方面却难以尽如人意。

如果想要查询数据为`K`的节点，使用有序向量速度是`O(logn)`级别，而使用列表则是`O(n)`级别。

另外就是，如果我们只查询节点而非指定数据，列表的速度是`O(1)`，因为我们可以直接查地址，不过这里我们也会发现，目前使用链表的存储对我们的意义只是遍历可能有点用，然而多叉树其实并不需要这种关联关系，我们只需要指定二叉树的根节点，就可以有多种方式遍历节点，因此对我们来说使用列表其实并没有意义。

更为理想的情况是，我们自由存储节点，然后构建新的关系指针，而无需维护列表节点的前后继关系。【事实上，这样和多叉树的抽象结构就有所相似了】

还有一点，因为多叉树的性质，使用列表在进行结构变动时，效率依旧很低。

# 问题：结构调整复杂
多叉树的调整不只是简单的节点插入或删除，同时涉及到结构的变更。

现在的一个主要问题是一旦对某个节点进行调整，比如将某个子树迁移到另一个节点上，因为对节点数没有限制，那么可能最多造成`O(n-1)`次调整。

如果不对节点数量进行控制，那么就难以真正实现高效处理，即使使用列表依旧可能导致`O(n)`级别的操作存在，加之频繁的插入删除操作，也使得问题出现的几率增大。

解决这一问题的方法很简单：使用限制子节点数量的二叉树，即可避免线性级别的结构调整，从而降低到`O(1)`

针对查询和修改，我们添加一条约束即可使其速度在两方面均达到`O(logn)`级别，这个约束：**同一节点之间的孩子必须具有某一线性约束**

基于此，有序二叉树也被叫做半线性结构，其内部的线性约束可以实现高效操作。

# 方式4 长子+兄弟
同样是存储所有节点，不过节点存储的信息变成：
1. 自身数据
2. 下一兄弟节点
3. 长子节点

目前来说，没有看到这种表示法的特殊意义，可能是比较容易转成二叉树？