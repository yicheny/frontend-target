以下均以多叉树为前提。

二叉树实例：

![](https://pic.imgdb.cn/item/6229c5575baa1a80ab183f26.jpg)

# 方式1 记录父节点位置
思路描述
1. 将所有节点都放到向量或列表中
2. 其中每个元素保存
   1. 自身信息
   2. 父节点的秩或位置【根节点的父节点可设置为-1或NULL】

保存信息如下：   

| 地址  | 数据 | 父节点位置 |
|---|---| --- |
| 0   | R | -1 |
| 1   | A | 0 |
| 2   | B | 0 |
| 3   | C | 0 |
| 4   | D | 1 |
| 5   | E | 1 |
| 6   | F | 3 |
| 7   | G | 6 |
| 8   | H | 6 |
| 9   | K | 6 |

评价下这种保存的优势：
1. 查询任一节点的父节点，速度都是`O(1)`

# 方式2 记录子节点线性表
思路描述
1. 将所有节点放到列表或向量中
2. 其中每个元素保存
   1. 自身信息
   2. 子节点组成的向量或链表

基本思路和方法1类似，只是将保存的信息由父节点改成子节点。

保存信息如下：

| 地址  | 数据 | 子节点列表   |
|---|---|---------|
| 0   | R | 1->2->3 |
| 1   | A | 4->5    |
| 2   | B | ^       |
| 3   | C | 6       |
| 4   | D | ^       |
| 5   | E | ^       |
| 6   | F | 7->8->9 |
| 7   | G | ^       |
| 8   | H | ^       |
| 9   | K | ^       |

评价下这种方式的优势：
1. 对于有x个孩子的节点而言，可在`O(x+1)`时间内列出所有孩子

# 方式3 记录父节点+子节点
可以看到：
1. 方式1父节点查询快速
2. 方式2子节点查询快速

我们可以同时保存两种信息以兼顾优势。

| 地址  | 数据 | 父节点 | 子节点  |
|--- | ---| --- |--- |
| 0   | R | -1 | 1->2->3 |
| 1   | A | 0 | 4->5    |
| 2   | B | 0 | ^       |
| 3   | C | 0 | 6       |
| 4   | D | 1 | ^       |
| 5   | E | 1 | ^       |
| 6   | F | 3 | 7->8->9 |
| 7   | G | 6 | ^       |
| 8   | H | 6 | ^       |
| 9   | K | 6 | ^       |

# 问题：动态维护复杂