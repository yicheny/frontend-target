二叉树遍历就是：按约定的次序，对所有节点进行访问，且只访问一次。

二叉树遍历可以分为4种：
- 先序
- 中序
- 后序
- 层次

接下来依次实现这4种遍历。

# 先序
所谓先序，就是以根节点为起点访问，然后访问左右节点。

## 递归实现
```c++
template <typename T, typename VST>
void travPre_R ( BinNodePosi(T) x, VST& visit ) { 
   if ( !x ) return; 
   visit ( x->data ); 
   travPre_R ( x->lc, visit ); 
   travPre_R ( x->rc, visit ); 
} 
```

递归实现非常简单，无需说明。

## 由递归至迭代

![VLR](https://pic.imgdb.cn/item/62258eda5baa1a80abeb0ab2.jpg)

模拟下执行：

## 迭代实现1
迭代实现无论是从空间复杂度还是时间速度上都比递归实现更优，代价是写法相对复杂。

思路描述
1. 从根节点开始，推入栈中
   1. 从栈中取出节点访问
   2. 将当前节点的左、右孩子推入栈中【注意：根据后进先出原则，先放右孩子】
2. 从栈中取出节点，重复执行迭代算法
```c++
template <typename T, typename VST> 
void travPre_I1(BinNodePosi(T) x, VST& visit) { 
   Stack<BinNodePosi(T)> S; 
   if (x) S.push(x); 
   while (!S.empty()) {
      x = S.pop(); 
      visit(x->data); 
      if (HasRChild(*x)) S.push(x->rChild); 
      if (HasLChild(*x)) S.push(x->lChild); 
   } 
} 
```

## 迭代实现2

![VLR](https://pic.imgdb.cn/item/62258eda5baa1a80abeb0ab2.jpg)

仔细观察，有另一种方式实现迭代：
1. 从根节点开始一路向左走到底
   1. 访问沿途经过节点数据
   2. 使用辅助栈记录下沿途节点的右孩子
2. 取出辅助栈节点，作为新起点，执行`最左侧通路`算法

```c++
template <typename T, typename VST> 
static void visitAlongLeftBranch ( BinNodePosi(T) x, VST& visit, Stack<BinNodePosi(T)>& S ) { 
   while ( x ) { 
      visit ( x->data ); 
      S.push ( x->rc ); //右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈） 
      x = x->lc; 
   } 
} 
  
 template <typename T, typename VST> 
 void travPre_I2 ( BinNodePosi(T) x, VST& visit ) {  
    Stack<BinNodePosi(T)> S;
    while ( true ) { 
       visitAlongLeftBranch ( x, visit, S );
       if ( S.empty() ) break; 
       x = S.pop(); 
    } 
 } 
```

