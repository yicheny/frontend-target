[TOC]

# 算法
## 要素
在本书，要求算法具备以下要素：
1. 输入输出
2. 确定性：可描述为由 若干语义明确的基本操作 组成的指令序列
3. 可行性：基本操作在 对应的算法模型中 均可实现
4. 有穷性：任意算法都应该在 执行有限次基本操作后 终止并给出输出
5. 正确性：给出的输出 符合问题预期的条件
6. 鲁棒性（robustness）：除一般性情况外，实用的算法还可以处理各种极端的输入实例
7. 重用性：从实用角度考虑，算法的总体框架能否便捷的推广至其他场合

### 证明算法的有穷性和正确性
审视计算过程，找出其中的**单调性**和**不变性**
- 单调性：问题的有效规模会随着算法的推进而递减
- 不变性：也称循环不变性，某个特质在初始状态成立，并且从当前状态到下一个状态的过程中能得以保持（这里运用了数学归纳法，如果每次都是对的，那么最终就是对的，由此可证算法正确性）

以冒泡算法为例：
经过x次冒泡后，最大的前x个元素必然归位，待求解问题的规模会缩减至n-x。

## 效率
- 可计算性：首先需要确定问题是否可被解决，例如：对于任何输入是否可以在有穷次操作后终止
- 难解性：问题可以被解决，但是代价非常大，比如：有穷操作终止前花费的时间成本太高
- 计算效率：本书优先关注**非不可解和难解**问题，并讨论高效率解决问题，两个基本点：
  - 为此需要建立一种尺度，从时间和空间角度对算法进行比较和评判
  - 研究和归纳算法设计和实现 的一般规律与技巧
- 数据结构：信息可以表示成不同的数据结构，数据结构的选择直接影响算法的执行效率，我们的目标是对相应的数据结构特性了然于心，才能自如的针对性进行选择。

# 复杂度度量
## 时间复杂度
首先，我们将针对特定算法处理规模为n的问题 的所需时间记为`T(n)`。

稍作思考我们可以发现，规模不是影响时间的唯一因素，相同规模的不同输入算法的处理时间也是不同的。

因此我们重新进行定义，针对处理规模为n的问题，我们将**执行时间最长**的时间记为`T(n)`，并以此度量该算法的时间复杂度。

### 渐进复杂度
对于同一问题的两个算法A、B，通过笔记时间复杂度TA(n)和TB(n)，及可评价两者对于同一输入规模n的计算效率高低。

不过，这种比较不足以对性能优劣做出整体性评价，比如有些算法在小规模输入时表现出色，有些则相反。

那么我们如何进行比较？

**我们忽略算法处理小规模问题的差异，而关注处理大规模问题的表现**，其原因很容易理解：小规模问题的处理时间本来就短，小差异无足轻重，而大规模输入的执行成本高，些许差异都将对执行效果带来巨大影响。

这种关注时间复杂度总体趋势变化的分析，即**渐进分析**

现在我们讨论针对足够大规模的输入n，算法执行时间T(n)的渐进增长速度，应如何度量和评价？

### 大O记号
> 注：以下表示复杂度时，c表示常数，f(n)表示函数

是对算法最坏情况的估计——对于规模为n的任意输入，运行时间绝不会超过`O(f(n))`（也可以从另一个角度考虑，我们关注的是渐进上界限）

相对而言，“最坏情况复杂度”是认为最为关注且使用最多的，有时候甚至是唯一的指标。比如说控制核电站已婚转，管理神经外科手术现场的系统，从最好或平均角度评价响应速度没有任何意义。

#### 数学推导
具体的，若存在正常数`c`和函数`f(n)`，使得任何 n>>2 都有：

`T(n) <= c*f(n)`

则可认为在`n`足够大以后，`f(n)`给除了`T(n)`增长速度的一个渐进上界，此时记为：

`T(n) = O(f(n))`

由此定义，可到处大O记号具有以下性质:
1. 对于任意常数c>0，有O(f(n)) = O(c*f(n))
2. 对于任意常数a>b>0，有O(n^a + n^b) = O(n^a)

对于第一个性质，意味着函数的各项**正常数可以忽略并等同于1**

对于第二个性质，意味着**多项式的低次项均可忽略，只需保留最高次项**

#### 实例：冒泡排序
对于`bubblesort1A`算法：
1. 由内、外两层循环组成
2. 内循环从前向后，以此比较每对相邻元素，如有必要则将其交换
3. 故每一轮内循环，需要比较n-1对元素，至多需交换n-1对元素
4. 外循环至多执行`n-1`轮
5. 因此，最多执行次数为`2*(n-1)^2`

以大O表示法表示：
```
T(n) 
=> O(2*(n-1)^2)
=> O(2n^2 - 4n + 2)
=> O(2n^2)
=> O(n^2)
```

### 大Ω
对算法最好情况进行估计（关注渐进下界），记为`Ω(g(n))`

### 大Θ
1. `Ω(g(n)) <= T(n) <= O(f(n))`
2. 若`f(n) = g(n)`，则可以使用`T(n) = Θ(h(n))`表示

## 空间复杂度
以上对时间复杂度所引入的记号同样适用于空间复杂度。

注意：空间复杂度**不计入原始输入本身所占用的空间**

我们更关注甚至仅关注时间复杂度，而忽略空间复杂度，原因在于：即使每次基本操作所占用的存储空间都是新开辟的，整个算法所需要的空间总量，也不过与基本操作的次数同阶。即，时间复杂度本身就是空间复杂度的天然上界

# 复杂度分析
1. 常数`O(1)` 最理想
2. 对数`O(logn)` 极为高效
3. 线性`O(n)` 令人满意
4. 多项式`O(n^c)` 可接受或可忍受的（可有效求解或易解）
5. 指数`O(c^n)` 不可接受或难以忍受（难解问题）

# 递归
价值
1. 许多应用问题都可以简洁的描述为递归形式，如文件系统的目录结构
2. 基本而典型的算法设计模式，可以对问题中反复出现的结构和形式做高度概括
3. 从程序结构而言，可以统筹纷繁多变的具体情况，避免复杂的分支及嵌套循环，从而更为简明的描述和实现算法，减少代码量，提高算法可读性，保证算法的整体效率

学习内容
1. 如何选择和应用不同的递归形式
   1. 线性递归
   2. 二分递归
   3. 多分支递归
2. 实现算法策略
   1. 遍历
   2. 分治
3. 分析递归算法复杂度
   1. 递归跟踪
   2. 递推方程

## 线性递归
示例：
```c++
int sum(const int A[],int n){
    if(n<1) return 0; //平凡情况-递归基
    return sum(A,n-1) + A[n-1];
}
```

保证线性递归有穷性的基本技巧：**首先判断并处理递归基**。

## 递归分析
### 递归跟踪
我们可以根据以下原则，将其整理为图的形式：
1. 算法的每一递归实例都表示为一个方框，其中注明了该实例调用的参数
2. 若实例M调用实例N，则在M与N 对应的方框之间 添加一条有向连线

以`sum`算法为例：

![sum递归分析图](https://pic.imgdb.cn/item/62021da42ab3f51d91ef73de.jpg)

以此图进行分析：
1. 首先对参数n进行调用，再转向对参数n-1进行调用，载转向对n-2进行调用……直至转向参数0的调用
2. 抵达递归基后停止递归
3. 将参数0的解返回给参数1的调用，参数1累加上`A[0]`之后返回给参数2的调用，参数2累加上`A[1]`返回给参数3的调用……最终返回给参数n的调用，此时累加上`A[n-1]`即为整个数组的总和

基于此，整个算法所需的时间为：所有递归实例 创建、执行和销毁 的时间总和。
- 其中，递归实例的创建、销毁均由操作系统负责完成，其对应的时间成本可以近似为常数，不会超过递归实例中是指计算所需要的时间成本，故往往进行忽略。
- 同时，启动各实例递归调用语句的时间成本也被忽略
- 我们只需要统计各地贵实例中非递归调用部分所需要的时间

以`sum`算法为例，每一递归实例中非递归部分包括：
1. 判断n是否为0
2. `sum(n-1) + A[n-1]`
3. 返回当前总和。

这3个都是基本操作，我们将每个递归实际所需计算时间记为`O(3)`，对长度为`n`的数组，递归深度为`n+1`，所以算法复杂度为：

`(n+1) * O(3) =  O(n)`

关于空间复杂度：
1. 在创建最后一个递归实例时（到达递归基），占用空间达到最大，为所有递归实例各自所占空间量的总和
2. 每一递归实例所需存放的数据，包括 参数及累加总和的临时变量，同样是常数规模
3. 所以空间复杂度同样是`O(n)`

### 递推方程
1. 通过对递归模式的数学归纳，
2. 导出 复杂度界定函数的 递推方程（组）及其边界条件
3. 从而将复杂度的分析，转化为对递归方程（组）的求解

以sum为例进行分析：
1. 为解决问题`sum(A,n)`，需递归解决问题`sum(A,n-1)`，然后累加上`A[n-1]`
2. 按这个角度理解，求解`sum(A,n)`所需要的时间，等于求解`sum(A,n-1)`的时间，另加一次整数加法运算的时间

基于以上分析，我们进行递推：
```
T(n) = T(n-1) + O(1) = T(n-1) + c1
T(n) = T(0) + n*c1 //注意，这里T(0)是递归基，和递归时间不同

T(0) = O(1) = c2 //sum(A,0)直接返回0，所以是O(0)
T(n) = c1*n + c2 = O(n)
```
递推方程同样可用于计算空间复杂度，这里不再演示

## 递归模式
### 多递归基
顾名思义，有多个递归基的递归。

我们使用此模式实现一个`reverse`方法：
```c++
void reverse(int *, int, int);
void reverse(int *A, int n) {
    reverse(A, 0, n - 1);
}

void reverse(int *A, int lo, int hi) {
    if (lo < hi) {
        std::swap(A[lo], A[hi]);
        reverse(A, lo + 1, hi - 1);
    }
    //注意，隐含的else包含两种递归基（大于等于）
}
```

### 多向递归
顾名思义，存在多个方向的递归，不过需要注意的是，虽然有多个方向，但是一个递归实例只会选择一个方向，所以依旧属于线性递归（稍后会讨论一个递归实例多次调用的情况）

我们以递归的方式将`pow(2,n) = 2^n`进行分析，可得到以下推导
- n=0,return 0;
- 否则，return 2*pow2(n-1)

此分析和`power2_1.cpp`的实现完全一致，此时间复杂度为`O(n)`

我们换一种角度思考`pow(2,n) = 2^n`问题。
```
2^1 
= 2^001b 
= (2^2^2)^0 * (2^2)^0 * 2^1 
= (2^2^0)^2 * (2^0)^2 * 2^1
= ((2^2^0) * (2^0))^2 * 2^1 
= ((2^0)^2 * (2^0))^2 * 2^1 //注意这里^的0,0,1恰好对应初始的001b
```

我们进行更多的推导，看看其中的规律：
```
2^0 = 2^000b = ((2^0)^2 * (2^0))^2 * 2^0
2^1 = 2^001b = ((2^0)^2 * (2^0))^2 * 2^1
2^2 = 2^010b = ((2^0)^2 * (2^1))^2 * 2^0
2^3 = 2^011b = ((2^0)^2 * (2^1))^2 * 2^1
2^4 = 2^100b = ((2^1)^2 * (2^0))^2 * 2^0
2^5 = 2^101b = ((2^1)^2 * (2^0))^2 * 2^1
2^6 = 2^110b = ((2^1)^2 * (2^1))^2 * 2^0
2^7 = 2^111b = ((2^1)^2 * (2^1))^2 * 2^1
……
```

一般的，若n有对应的二项展开式`b1b2b3……bk`（即010b这种），则有
```
2^n = (……((2^b1)^2 * 2^b2)^2 * 2^b3)^2 …… * 2^bk
```

若`nk`的展开式为`b1b2b3……bk`,`n(k-1)`的展开式为`b1b2b3……b(k-1)`,则可得：
```
2^nk = (2^n(k-1))^2 * 2^bk

//若bk为b二项式最低位,且ak=bk-1
//这个表达式就是
2^b = (2^ak)^2 * 2^bk
```

基于此，我们可以归纳出`pow(2,n) = 2^n`的递推式：
```
若bk=0，=> pow2(nk-1)^2
若bk=1，=> pow2(nk-1)^2 * 2

//其实就是 pow2(nk-1)^2 * 2^bk
```

`c++`代码实现如下：
```c++
inline __int64 sqr(__int64 a) { return a * a; }

//前提：禁止超过1位的移位运算
//对任意非负整数n，计算幂2^n
__int64 power2(int n) {
    if (0 == n) return 1;
    return (n&1) ? sqr(power2(n>>1)) << 1 : sqr(power2(n>>1));
}
```

# 抽象数据类型（ADT）
数据结构可看作是 由数据项组成的集合，同时对数据项定义一组标准的操作

**封装**，即 将数据项和相关操作结合为统一整体，将外部的可见性分为若干级别，从而将数据结构的外部特性和其内部的实现相分离，提供一直且标准的对外接口，隐藏内部的实现细节。

# 名词
- **算法**：基于特定的计算模型，用于解决某一特定问题而设计的一个指令序列
- **时间复杂度**：算法执行时间的变化趋势为 输入规模的一个函数，称作该算法的复杂度
- **递归基**：不需要进行递归的基本情况，如`n==0`
- **线性递归**：每一递归实例对自身至多调用一次。（每一层次至多只有一个实例，且它们构成一个线性的次序关系）
- **减而治之**：递归每深入一层，待求解问题规模都缩减一个常数，直至最终变化为递归基。

# 资料
- [可计算性理论](https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E7%90%86%E8%AE%BA)