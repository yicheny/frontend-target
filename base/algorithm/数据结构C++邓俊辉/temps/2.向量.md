[TOC]

数据结构是 数据项的结构化集合， 其结构性表现为**数据项之间的相互联系及作用**， 也可以理解为定义**数据项之间的某种逻辑次序**

根据逻辑次序复杂程度，可以将各种数据结构分为：
1. 线性结构
2. 半线性结构
3. 非线性结构

# 空间管理
## 静态空间管理
静态空间管理策略可能出现容量不足的情况。

针对这种情况我们使用动态空间管理策略。

动态空间管理策略的一个重点在于：如果保证装填因子不超过1，同时又不接近0？

## 动态空间管理策略
动态空间管理的一个有效手段是**可扩充向量**

可扩充向量的难点是：
1. 如何实现扩容？
2. 扩容空间取多大合适？

容易想到的方案是 直接在原物理空间上追加空间？

这个想法是不可行的，原因在于数组的定址方式要求空间必须连续，而如果是物理地址追加方案，则无法保证尾部预留足够的空间进行扩展。

合理的方式：申请另一个容量更大的数组，并将原数组中的成员集体搬迁至新数组。【注意：需要释放原数组空间】

可以发现，这种做法有额外的迁移成本。准确分析的话就是，每次n到2n的扩容，都需要付出`O(2n)=O(n)`的时间代价。

表明上看这种策略似乎效率极低，但这是错觉，这个方案极为优秀，无论是时间复杂度还是空间利用率上。

注意，每花费`O(n)`时间实现一次扩容，这意味着，至少经过n次插入，才可能再次扩容，所以实际用于的扩容成本分摊下来实际上是`O(1)`

另一方面，这种扩容效率极高，即使是容量1扩容至容量100000000，也不过20次左右扩容，实际迁移次数是`O(2n-1)=O(n)`，而可以想象的是，当容量为1亿，再次进行扩容的概率极低，大部分操作时都无需进行扩容。

从分摊运行时间分析，迁移的成本实际是`O(1)`

另一点则是这种做法有效保证了装填因子在`50%-100%`之间

代码实现：
```c++
template <typename T>
void Vector<T>::expand() {
    if(_size < _capacity) return ;
    if(_capacity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY;
    T* oldElem = _elem;
    _elem = new T[_capacity << 2];//容量加倍
    for(int i = 0;i<_size;i++) _elem[i] = oldElem[i];
    delete [] oldElem;
}
```

### 其他策略：追加固定空间
早期向量有采用另一策略：一旦有必要，追加固定容量空间。这种做法既无法保证装填因子的利用率，同时也会导致单次操作的分摊时间复杂度高达`Ω(n)`，无论是上限还是下限迁移效率都无法让人满意【比如说设定固定追加空间为10000，那么在小容量扩充时，比如我只需要扩容2个单位空间，但是这种策略却需要10000次迁移；另一方面，如果需要扩容100000000空间容量，这种做法需要扩充10000次，那么最终扩容效率会是`O(n^2)`【注意，这里的n是100000000】，比加倍扩容策略速度高一个数量级）

# 有序向量
## 二分查找A
复杂度`O(1.5 * logn)`
```c++
//有多个命中时，此实现不保证返回秩最大者；
template <typename T>
static Rank binSearch(T* A,T const& e,Rank lo,Rank hi){
    while (lo < hi){
        Rank mi = (lo + hi) >> 1;//以中点为轴点
        if(e<A[mi]) hi = mi;//深入前半段[lo,mi)查找
        else if(A[mi] < e) lo = mi + 1;//深入后(mi,hi)半段查找
        else return mi; //在mi处命中
    }
    return -1;//查找失败
}
```

## Fibonacci查找A
复杂度`O(1.44 * logn)`
```c++
template <typename T> static Rank fibSearch(T* A, T const& e, Rank lo, Rank hi){
    Fib fib(hi - lo);
    while(lo < hi){
        while( hi-lo < fib.get()) fib.prev();
        Rank mi = lo + fib.get() -1;
        if(e < A[mi]) hi = mi;
        else if(A[mi] < e) lo = mi;
        else return mi;
    }
    return -1;
}
```

## 二分查找B
```c++
//有多个命中时，此实现不保证返回秩最大者；
template<typename T>
static Rank binSearch(T *A, T const &e, Rank lo, Rank hi) {
    while (1 < hi - lo) {
        Rank mi = (lo + hi) >> 1;
        (e < A[mi]) ? hi = mi : lo = mi;
    }
    return (e == A[lo]) ? lo : -1;
}
```


# 名词
- **序列**(sequence)：最基本的线性结构通常为序列
- **列表**(list)：逻辑相邻的数据项物理上未必相邻
- **向量**(vector)：数据项的物理存放位置与逻辑次序吻合
- **秩**(rank)：向量的逻辑次序
- **数组**(array)：物理地址连续的一段存储空间
- **前驱**(predecessor)：对于任何`0<=i<j<n`，`A[i]`都是`A[j]`的前驱
- **直接前驱**(immediate predecessor)：对于`0<=i<i+1<n`，`A[i]`是`A[i+1]`的直接前驱
- **前缀**(prefix)：任一元素的所有前驱构成其前缀
- **后继**(successor)：对于任何`0<=i<j<n`，`A[j]`都是`A[i]`的后继
- **直接后继**(immediate successor)：对于`0<=i<i+1<n`，`A[i+1]`是`A[i]`的直接后继
- **后缀**(suffix)：任一元素的所有后继构成其前缀
- **线性数组**(linear array)：元素的物理地址与其下标满足`start + i*s`，故称线性数组
- **循秩访问**(call-by-rank)：通过`r`可确定唯一的`e=v[r]`，这是向量特有的元素访问方式
- **静态空间管理策略**：在生命周期内不允许调整所占物理空间的容量。
- **装填因子**(load factor)：向量实际规模与其内部数组容量的比值
- **可扩充向量**(extendable vector)：若内部数组有空余，则操作正常进行，一旦空用空间好久，则动态扩大内部数组容量
- **分摊运行实际**(anmortized running time)：
- **平均运行时间**(average running time)：
- **比对**：判断两个对象是否相等
- **比较**：判断两个对象的相对大小
- **输入敏感算法**（input sensitive）：对于规模相同、内部组成不同的输入，渐进运行时间却有本质区别的算法。
- **有序向量**（sorted vector）：所有元素不仅按线性次元存放，而且其数值大小也按次次序单调分布。