[TOC]

数据结构是 数据项的结构化集合， 其结构性表现为**数据项之间的相互联系及作用**， 也可以理解为定义**数据项之间的某种逻辑次序**

根据逻辑次序复杂程度，可以将各种数据结构分为：
1. 线性结构
2. 半线性结构
3. 非线性结构

# 空间管理
## 静态空间管理
静态空间管理策略可能出现容量不足的情况。

针对这种情况我们使用动态空间管理策略。

动态空间管理策略的一个重点在于：如果保证装填因子不超过1，同时又不接近0？

## 动态空间管理策略
动态空间管理的一个有效手段是**可扩充向量**

可扩充向量的难点是：
1. 如何实现扩容？
2. 扩容空间取多大合适？

容易想到的方案是 直接在原物理空间上追加空间？

这个想法是不可行的，原因在于数组的定址方式要求空间必须连续，而如果是物理地址追加方案，则无法保证尾部预留足够的空间进行扩展。

合理的方式：申请另一个容量更大的数组，并将原数组中的成员集体搬迁至新数组。【注意：需要释放原数组空间】

可以发现，这种做法有额外的迁移成本。准确分析的话就是，每次n到2n的扩容，都需要付出`O(2n)=O(n)`的时间代价。

表明上看这种策略似乎效率极低，但这是错觉，这个方案极为优秀，无论是时间复杂度还是空间利用率上。

注意，每花费`O(n)`时间实现一次扩容，这意味着，至少经过n次插入，才可能再次扩容，所以实际用于的扩容成本分摊下来实际上是`O(1)`

另一方面，这种扩容效率极高，即使是容量1扩容至容量100000000，也不过20次左右扩容，实际迁移次数是`O(2n-1)=O(n)`，而可以想象的是，当容量为1亿，再次进行扩容的概率极低，大部分操作时都无需进行扩容。

从分摊运行时间分析，迁移的成本实际是`O(1)`

另一点则是这种做法有效保证了装填因子在`50%-100%`之间

代码实现：
```c++
template <typename T>
void Vector<T>::expand() {
    if(_size < _capacity) return ;
    if(_capacity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY;
    T* oldElem = _elem;
    _elem = new T[_capacity << 2];//容量加倍
    for(int i = 0;i<_size;i++) _elem[i] = oldElem[i];
    delete [] oldElem;
}
```

### 其他策略：追加固定空间
早期向量有采用另一策略：一旦有必要，追加固定容量空间。这种做法既无法保证装填因子的利用率，同时也会导致单次操作的分摊时间复杂度高达`Ω(n)`，无论是上限还是下限迁移效率都无法让人满意【比如说设定固定追加空间为10000，那么在小容量扩充时，比如我只需要扩容2个单位空间，但是这种策略却需要10000次迁移；另一方面，如果需要扩容100000000空间容量，这种做法需要扩充10000次，那么最终扩容效率会是`O(n^2)`【注意，这里的n是100000000】，比加倍扩容策略速度高一个数量级）

# 有序向量
## 二分查找A
复杂度`O(1.5 * logn)`
```c++
//有多个命中时，此实现不保证返回秩最大者；
template <typename T>
static Rank binSearch(T* A,T const& e,Rank lo,Rank hi){
    while (lo < hi){
        Rank mi = (lo + hi) >> 1;//以中点为轴点
        if(e<A[mi]) hi = mi;//深入前半段[lo,mi)查找
        else if(A[mi] < e) lo = mi + 1;//深入后(mi,hi)半段查找
        else return mi; //在mi处命中
    }
    return -1;//查找失败
}
```
这个算法的核心思路就是：每次半分查找，则规模依次减半，最坏情况需要`O(logn)`找到结果，很容易理解。

划分逻辑描述：
- 如果目标值小于轴点，则向前半段查找
- 如果目标值大于轴点，则向后半段查找
- 否则命中目标值，直接返回

基于此，我们可以判断最好的情况，也需要经历2次判断才能命中目标。

另一方面，我们从查找长度看一下，假设我们在长度为`7`的数组中查找任意值，查找长度如下（注：方块内表示长度） ：

![](https://pic.imgdb.cn/item/620d93702ab3f51d9157778c.jpg)

从图中可以看出，向前半段前进需要1次判断，向后半段需要2次判断。

简单计算下平均查询长度：

(2+3+4+4+5+5+6) / 7 = 4.14;

### 复杂度推导
首先我们将所有元素对应的查找总和记作`C(K) = C.average(K) * (2^k - 1)`

对于长度`n=(2^k-1)`的有序向量，每步迭代都有3种可能的分支：
1. 【前】经过1次成功的比较后，转换为1个规模为`2^(k-1) - 1`的新问题
2. 【后】经过1次成功的比较、1次失败的比较后，转换为1个规模为`2^(k-1)-1`的新问题
3. 【命中】经过2次失败的比较后，成功命中，终止迭代

成功查找属于特殊的边界情况：`C.average(1) = C(1) = 2`

基于以上分析，可得：
```
//前深入 + 命中 + 后深入
C(K) = [C(k-1) + (2^(k-1) - 1)] + 2 + [C(K-1) + 2*(2^(k-1)) - 1)]   
     = 2*C(k-1) + 3*(2^(k-1)) - 1
     
若令：
F(K) = C(k) - 3k*2^(k-1) - 1
则有：
F(1) = -2;
F(k) = 2K(K-1) 
     = 2^2 * F(k-2)
     = 2^3 * F(k-3)
     = ...
     = 2^k-1 * F(1)
     = -2^k
于是：
C(K) = F(K) + 3k*2^(k-1) + 1
     = -2^k + 3k * 2^(k-1) + 1
     = (3k/2 - 1) * (2^k-1) + 3k/2
进而：
C.average(K) = C(K) / (2^k-1)
             = 3k/2 -1 + 3k/2/(2^k-1)
             = 3k/2 + O(ε)
就是说，忽略末尾趋于收敛的波动项，则平均查找长度为：
O(1.5k) = O(1.5 * logn)
```

### 优化方案
从推导式中不难看出，其平均复杂度主要取决于于`(2^(k-1) - 1)`和`2*(2^(k-1) - 1)`两项，系数1和2分别为深入前、后段的操作次数。

这两项大小不匹配，因而使得均衡性方面存在缺陷，故此我们的解决思路是：
1. 调整分隔区比例，以当前算法来说，可适当加上前段比例
2. 统一沿两个方向深入所需要执行的次数，比如统一为1次。

首先介绍第一种思路的实现方案：Fibonacci查找

## Fibonacci查找
分治策略并不要求必须等分，fibonacci算法使用黄金分割比来设定轴点mi：
```
n = fib(k) - 1 //总长
hi = fib(k-1) - 1 //前
lo = fib(k-2) - 1 = n - hi  - 1 //后
```

实现如下：
```c++
template<typename T>
static Rank fibSearch(T *A, T const &e, Rank lo, Rank hi) {
    Fib fib(hi - lo);//当生成值大于等于n时停止
    while (lo < hi) {
        while (hi - lo < fib.get()) fib.prev();
        Rank mi = lo + fib.get() - 1;
        if (e < A[mi]) hi = mi;
        else if (A[mi] < e) lo = mi + 1;
        else return mi;
    }
    return -1;
}
```

同样是在长度为`7`的数组中查找任意值，我们看下这种算法的查找长度 ：

![](https://pic.imgdb.cn/item/620efa892ab3f51d9142d612.jpg)

简单计算下平均查询长度：

(2+3+4+4+5+5+5) / 7 = 4.00;

### 复杂度推导
我们将长度记作`n=fib(k)-1`

则所有元素对应的查找总和记作`C(K) = C.average(K) * (fib(k)-1)`

```
C.average(2) = C(2) = 0
C.average(3) = C(3) = 2
C(k) = ...
```

最终结论：`O(k) = O(1.44 * logn)`，效率略有提高

## 二分查找B
核心策略是：三分支变两分支，当成为单区间时停止。
```c++
//有多个命中时，此实现不保证返回秩最大者；
template<typename T>
static Rank binSearch(T *A, T const &e, Rank lo, Rank hi) {
    while (1 < hi - lo) { // 区间大于等于1时停止
        Rank mi = (lo + hi) >> 1;
        (e < A[mi]) ? hi = mi : lo = mi;
    }
    return (e == A[lo]) ? lo : -1;
}
```

同样是在长度为`7`的数组中查找任意值，我们看下这种算法的查找长度 ：

![](https://pic.imgdb.cn/item/620efa892ab3f51d9142d612.jpg)

简单计算下平均查询长度：

(3+4+4+4+4+4+4) / 7 = 3.85;

可以看到速度进一步提升，这种算法策略在最好查询时效率降低，在最差查询时长度效率降低，最终综合效率是提升的。

这种算法各分支长度更加接近，故整体性能更趋于稳定。

## 二分查找C
解决两个问题：
1. 保证查询结果是其中秩最大者
2. 查找失败是返回不大于e的最后一个元素（或不小于e的前一个元素），以便将e作为后继（或前驱）插入向量

```c++
template<typename T>
static Rank binSearch(T *A, T const &e, Rank lo, Rank hi) {
    //有效区间宽度缩短为0（而非1）时终止查找
    // lo>=hi时停止，此时可确定 e>=A[mi]
    //通过数学归纳法可证明：
    //A[0,lo)的元素皆不大于e；A[hi,0)的元素皆大于e
    while(lo < hi){ 
        Rank mi = (lo + hi) >> 1;
        (e < A[mi]) ? (hi =  mi) : (lo = mi+1);
    }
    return --lo;//A[lo-1)是不大于e的最后一个元素
}
```

# 排序与下界
算法优化的一个基本原则是：必须要了解该问题的复杂度下界。

此原则基于1个简单的事实：算法的效率存在一个极限，这个极限就是复杂度下界，当算法性能达到这一下界，就证明它已经到达最坏场景下的最低计算成本。

## 比较树
比较树具有以下性质：
1. 每一个内部节点个对应于一次对比操作
2. 内部节点的左右分支，分别对应于对比结果下的两种执行方向
3. 叶节点（或等效的，根到叶节点的路径）对应于算法某次执行的完整过程即输出
4. 翻过拉力，算法的每一运行过程都对应于从根到某一叶节点的路径

按上述规则与算法对应的树，称作比较树。

符合此描述的算法，都称作**基于比较式算法**

# 名词
- **序列**(sequence)：最基本的线性结构通常为序列
- **列表**(list)：逻辑相邻的数据项物理上未必相邻
- **向量**(vector)：数据项的物理存放位置与逻辑次序吻合
- **秩**(rank)：向量的逻辑次序
- **数组**(array)：物理地址连续的一段存储空间
- **前驱**(predecessor)：对于任何`0<=i<j<n`，`A[i]`都是`A[j]`的前驱
- **直接前驱**(immediate predecessor)：对于`0<=i<i+1<n`，`A[i]`是`A[i+1]`的直接前驱
- **前缀**(prefix)：任一元素的所有前驱构成其前缀
- **后继**(successor)：对于任何`0<=i<j<n`，`A[j]`都是`A[i]`的后继
- **直接后继**(immediate successor)：对于`0<=i<i+1<n`，`A[i+1]`是`A[i]`的直接后继
- **后缀**(suffix)：任一元素的所有后继构成其前缀
- **线性数组**(linear array)：元素的物理地址与其下标满足`start + i*s`，故称线性数组
- **循秩访问**(call-by-rank)：通过`r`可确定唯一的`e=v[r]`，这是向量特有的元素访问方式
- **静态空间管理策略**：在生命周期内不允许调整所占物理空间的容量。
- **装填因子**(load factor)：向量实际规模与其内部数组容量的比值
- **可扩充向量**(extendable vector)：若内部数组有空余，则操作正常进行，一旦空用空间好久，则动态扩大内部数组容量
- **分摊运行实际**(anmortized running time)：
- **平均运行时间**(average running time)：
- **比对**：判断两个对象是否相等
- **比较**：判断两个对象的相对大小
- **输入敏感算法**（input sensitive）：对于规模相同、内部组成不同的输入，渐进运行时间却有本质区别的算法。
- **有序向量**（sorted vector）：所有元素不仅按线性次元存放，而且其数值大小也按次次序单调分布。
- **内部排序算法**：处理数据规模相对不大，内存可以容纳
- **外部排序算法**：数据规模很大，必须借助外部甚至分布式存储器，在排序计算的任一时刻，内存中只能容纳其中一小部分数据
- **离线算法**（offline algorithm）：数据以批处理的形式整体给出
- **在线算法**（online algorithm）：网络环境中，数据需要实时生成，启动后数据陆续送达
- **复杂度下界**（lower bound）：任一问题在最坏情况下的最低计算成本
- **稳定算法**（stable algorithm）：
- **不稳定算法**（unstable algorithm）：
- **二路归并**（2-way merge）：将两个有序序列合并成一个有序序列。