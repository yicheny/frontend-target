
# 加法运算
二进制加法表（记住这个）：
```
0+0=0
0+1=1
1+0=1
1+1=10
```

我们可以将这个加法表转换为前导0的形式：
```
0+0=00
0+1=01
1+0=01
1+1=10
```

我们现在将前面的位置叫做**进位位**（carry bit），将后面的位置叫做**加法位**（sum bit）

由此，我们可以将原来的运算表拆分成两份。

## 进位位
第一份是进位位运算表：
```
0,0 => 0
0,1 => 0
1,0 => 0
1,1 => 1
```

运算结果和与门完全一致，所以我们可以使用与门电路实现进位。

## 加法位
第二份是加法位运算表：
```
0,0 => 0
0,1 => 1
1,0 => 1
1,1 => 0
```

运算结果和目前已知的四种逻辑门都不一致。

不过，或门和与非门的结果和加法位输出很相似，我们列表对比下

| 输入 | 加法位 | 或门 | 与非门 |
| -- | -- | -- | -- | 
| 0,0 | 0 | 0 | 1 | 
| 0,1 | 1 | 1 | 1 | 
| 1,0 | 1 | 1 | 1 | 
| 1,1 | 0 | 1 | 0 | 

我们先将 或门 和 与非门 连接到相同的输入上，如图：

![](https://pic.imgdb.cn/item/6184fbd92ab3f51d91462f59.jpg)

我们将或门和与非门作为输入，对比需要的加法位输出：
| 或门 | 与非门 | 加法位 |
| -- | -- | -- |
| 0 | 1 | 0 |
| 1 | 1 | 1 |
| 1 | 1 | 1 |
| 1 | 0 | 0 |

这正是**与门**的运算表，因此，我们将或门和与非门通过与门连接，就可以实现加法位的运算啦！

![异或门](https://pic.imgdb.cn/item/6184fcb12ab3f51d91478333.jpg)

这个电路图叫做**异或门**，简写**XOR**，符号如下

![异或门-符号](https://pic.imgdb.cn/item/618510c62ab3f51d915de077.jpg)

## 结合-半加器
我们将加法位和进位位电路结合，即可实现单位二进制计算，如图：

![半加器-电路](https://pic.imgdb.cn/item/618511892ab3f51d915ea0a5.jpg)

这个电路可以使用以下符号表示：

![半加器-符号](https://pic.imgdb.cn/item/618512042ab3f51d915f2811.jpg)

这个符号叫做半加器，之所叫半加器，是因为它只能计算1位的二进制数相加，而绝大多数二进制数是多余1位的。

半加器**没有将进位位纳为下一次运算**，这是全加器需要做到的。

## 多位二进制计算
我们来看一个多位二进制的计算：
```
    1111
+   1111
=  11110
```
实际从第二列开始，由于进位位的存在，需要将三个二进制数相加。

将2个半加器和1个或门做连接：

![全加器-电路](https://pic.imgdb.cn/item/6185134c2ab3f51d9160d526.jpg)

注意这里，你可能认为使用半加器而非或门进行进位运算是更合理的做法？

实际上并不是，使用半加器当然可以，但这里使用或门已经足够，因为两个进位不可能同时为1。

一个简单推论：第一个进位为1，则加法位必为0，则第二个进位必为0；

所以实际上只可能存在三种情况
```
0,0 0
1,0 1
0,1 1
```

这里使用或门已经足够。

全加器可以用如下符号表示：

![全加器符号](https://pic.imgdb.cn/item/618514ae2ab3f51d9163232f.jpg)
