[TOC]

# 自动加法器
我们看一下在14章实现的加法器：

![加法器](https://pic.imgdb.cn/item/61ed685d2ab3f51d916c27e8.jpg)

这个加法器的设计在计算大量数字累加时体验很差，假设我们需要将一个数累加100次，当我们费劲千辛万苦累加完之后，结果却是错误的，原因在于我们在输入过程中输错了一两个值，按现在的模式我们很难知道是哪里出错了，想要重新计算需要再输入100次——这个体验无疑是非常糟糕的。

如果，如果我们将中间输入的结果进行保存，一旦出错，我们想要排查或者重新计算会简单很多。

想要实现中间结果保存，我们只需要将累加器和RAM阵列连接即可实现。

如何实现对累加器和RAM阵列的连接？

改造：
1. 使用16位计数器控制RAM阵列地址信号
2. 去除数据输入信号和写操作信号

最终连接如图：

![累加器+RAM阵列](https://pic.imgdb.cn/item/61ef4a002ab3f51d910149ae.jpg)

我们看下怎么使用这个设置：
1. 闭合清零开关
   1. 清除8位锁存器内容
   2. 将16位计数器输出置为`0000h`
2. 断开`RAM`控制面板的控制端开关
3. 现在可以使用控制面板从地址0000h开始输入一组需要相加的8位数
   1. 如果有100个数，会被存储在0000h~0063h的地址空间中
4. 闭合`RAM`控制面板的控制开关【交由外部电路控制】，同时断开清零开关
   1. 然后可以发现运算会进行自动运算

分析下装置的自动运行原理：
1. 振荡器的存在使得地址逐步累加，从`0000h`行进至`0063h`
2. 每次地址变化，RAM阵列都会输出所在地址的数据
3. RAM阵列的输出值会成为加法器的A端输入值
4. 而B端输入则是之前的累加值
5. 至`0063h`，则可实现100位数字的累加

这个电路存在两个问题：
1. 振荡器自动运作，我们没办法停止
2. 只能做加法运算，并且只能做8位加法的运算。

解决8位运算的一个简单方案是将RAM阵列、加法器、锁存器位宽全部加倍，不过这个在我们看来是不合算的，而且指标不治本，因为可能16位也不够。

# “代码”RAM阵列
这个问题我们最终会解决，不过我们先关注另一个问题。

假设，我们假设
- 现在要做的不是对100个数字进行累加
- 而是对50对数字累加，得到50个结果
- 又或者我们希望可以方便的2个数、10个数、100个数进行累加
- 我们希望所有结果都可以被方便的使用

首先，如果我们想要复用结果，那么就需要保存结果，之前我们使用灯泡作为加法器输出，在我们目前的功能需求中，这不是一个好的设计。稍微改造下：
1. 将加法器输出灯泡这段连接去掉
2. 将加法器输出连接到RAM阵列进行保存
3. 在控制面板上添加灯泡，以便检查对应地址的数据。

新的电路设计如下：

![RAM阵列保存加法器输出](https://pic.imgdb.cn/item/61ef6a4b2ab3f51d911c1f93.jpg)

> 这里略去了自动加法器和其他部分，包括振荡器和清零开关，我们不再特别标注

可以发现，新的电路中，我们将加法器输出作为RAM阵列的数据输入端。

现在我们思考加法器的问题，如何配置一个自动加法器，使其
1. 不仅仅可以对一组数字做累加运算，还可以自主确定累加多少个数字
2. 能记住在RAM中存放了多少多少个计算结果，这个可以简化查询工作

比如说，我们想对3个数求和，然后对2个数求和，最后再对3个数求和。

假设我们把这些数据保存在RAM阵列中以0000h开始的一组空间中：

![](https://pic.imgdb.cn/item/61ef88c22ab3f51d91363ce1.jpg)

之前的加法器是单任务系统，现在它需要完成4件事
1. 【加载】把一个字节从存储器传送到累加器中，这个操作称作加载（Load）
2. 【相加】把存储器中的一个字节加（Add）到累加器的内容中
3. 【保存】把累加器的计算结果取出并存放到存储器中
4. 【终止】除以上之外，还需要一个方法让自动加法器停（Halt）下来

使用刚刚的例子，我们描述下自动加法器的运算过程：
1. 将0000h地址的内容【加载】到累加器
2. 将0001h地址的内容【相加】到累加器
3. 把0002h地址的内容【相加】到累加器
4. 把累加器的内容【保存】到0003h地址
5. 将0004h地址的内容【加载】到累加器 
6. 将0005h地址的内容【相加】到累加器
7. 把累加器的内容【保存】到0006h地址
8. 将0007h地址的内容【加载】到累加器 
9. 将0008h地址的内容【相加】到累加器 
10. 把0009h地址的内容【相加】到累加器 
11. 把累加器的内容【保存】到000Ah地址
12. 另自动加法器【终止】工作

我们可以用一些数字代码来标识加法器所进行的每一项工作：加载、相加、保存、终止。

1. 存放这些代码最简单的方法是将它们存放在RAM阵列中
2. 这个RAM应该和第一个RAM【数据】同时被访问
3. 这个RAM存放的不是数据，而是一些数字代码，用于标记自动加法器对第一个RAM中指定地址要做的一种操作
4. 这两个RAM可以分别标记为数据和代码

电路构成如下：

![](https://pic.imgdb.cn/item/61ef91cf2ab3f51d913f851a.jpg)

现在的设计中，自动加法器可以将数据求和结果写入到数据RAM阵列，而代码阵列则只能通过控制面板写入。

我们使用4个代码来标记自动加法器需要的4个操作，代码可以任意指定，比如下表就是一种方案：

| 操作码 | 代码 | 
| :---: | --- |
| Load（加载） | 10h |
| Store（保存） | 11h |
| Add（相加） | 20h |
| Halt（停止） | FFh |

这种数字代码常常被称作**指令码**或**操作码**，它们指示电路要执行的某种操作。

为了让之前的三组加法正常执行，我们需要通过控制面板将以下值存入代码RAM阵列

![](https://pic.imgdb.cn/item/61ef92fd2ab3f51d9140d7c9.jpg)

- 【Save】自动加法器的8为锁存器输出作为数据RAM阵列的输入，这就是Save指令对应的功能
- 【Load】数据RAM阵列的输出有时也需要作为8位锁存器的输入，`Load`功能需要一个`2-1`选择器实现。

改进后的电路图如下：

> 电路图省略了控制组件的信号，这些信号同成位控制信号，比如16位计数器的“时钟”输入和“清零”输入，8位锁存器的“时钟”输入和“清零”输入，数据RAM阵列的“写输入”等等

![](https://pic.imgdb.cn/item/61ef94322ab3f51d91420e5c.jpg)

分析下这个电路：
- 16位计数器为两个RAM阵列提供地址输入【现在的设计中指令码和数据要使用相同的地址】
- RAM数据阵列可以将数据作为8位加法器的输入【Add操作】
- RAM数据阵列可以将数据直接输入到8位锁存器【Load操作】
- 8位锁存器的输出可以保存到RAM数据阵列【Save操作】，同时也是8位加法器的一侧输入

# 实现减法
现在我们考虑让这个电路实现减法功能。

之前我们实现过减法器，减法的关键操作是什么？

**减去一个数，等于加上这个数的倒数，再加1**

在电路上实现这个逻辑即可，进行两个操作：
1. RAM阵列数据传入加法器前取反
2. 加法器进位置1

其他操作和普通加法操作相同。

改造后电路图【只加了一个C0反相器】：

![](https://pic.imgdb.cn/item/61ef9d082ab3f51d914b4188.jpg)

我们可以为减法操作添加一个操作码：`Subtract（减法） => 21h`

假设我们想吧56h和2Ah相加，然后从中减去38h，RAM阵列的代码和数据如下：

![](https://pic.imgdb.cn/item/61ef9db22ab3f51d914be92b.jpg)

现在我们回到位宽不足的问题。

# 解决位宽不足
我们不采取增加位宽的方案，有更好的方案。

## 进位加法
这里8位宽已经足够，甚至可以说富裕，只需要1位的位宽，就可以实现近乎无限大位数的加法运算，我们只需要了解一点关于数学运算的小知识。

> 其实在《汇编语言-王爽》的书里我已经了解了相关原理。

实际只需要保留进位即可，以十进制为例，我们现在单次只能进行2位数的加法【即两个输入最大只能是2位数】

现在展示，我们如何使用两个2位输入，和一个寄存器实现8位大数加法：
```
计算77224488+11115566

- 默认CF=0

//1. 将77224488和11115566两位数字一组分组
77224488分组得到[77,22,44,88]
11115566分组得到[11,11,55,66]

//2. 对第一组进行相加
66+88+CF = 154+0 = 154
取54保存，此时内存值54，CF变为1

//3. 对第二组进行相加
44+55+CF = 99+1 = 100
取00保存，此时内存值0054，CF变为1

//4. 对第三组进行相加
22+11+CF = 33+1 = 34
取34保存，此时内存值为340054，CF变为0

//5. 对第四组进行相加
77+11+CF = 88+0 = 88
取88保存，此时值为88340054，CF变为0

最终结果为88340054，实际使用计算机验算无误
```

现在回到十六进制，假设我们想实现十六进制`76ABh`和`236Ch`相加，我们还是使用现在的8位加法器，运算如下：
```
1. 每2位分成一组【2位十六进制等于8位二进制】
76ABh 分组 得到 [76h,ABh]
236Ch 分组 得到 [23h,6Ch]

2. 对第一组相加
ABh + 6Ch = 117h【进位1】

3. 对第二组相加
76h + 23h + 1h[进位] = 9Ah
```
最后结果是`9A17h`，我们会在RAM阵列中使用两个字节保存结果。

可以看到，想要实现多位运算，我们只需要增加一个进位即可，进位只需要使用1位锁存器。

为了使用这个操作，我们添加一个新的操作码，称作“进位加法”（Add with Carry）

## 借位减法
如果需要进行16位的减法运算，则同样需要一个新的指令，称为“借位减法”（Subtract and Borrow）

我们利用十进制来演示借位减法运算过程：
```
计算56283544-32791888

- 默认CF=1

//1. 分组
[56,28,35,44]
[32,79,18,88]

//2. 进行第一组运算
44 - 88 = 44+11+1 = 56 
CF=0，保存56

//3. 进行第二组运算
35 - 18 = 35+81+0 = 116
CF=1，保存16

//4. 进行第三组运算
28-79 = 28+20+1 = 49
CF=0，保存49

//5. 进行第四组运算
56-32 = 56+67 = 123
CF=1，保存23

最终结果为23491656，实际使用计算机验算无误
```
- 如果发生借位，则CF为0，在高位运算时使用CF为0，则等同于借与低位1
- 如果没发生借位，则CF为1，则在高位运算是使用CF为1，则与正常减法相同

借位减法可以和进位加法共同同一个锁存器，我们暂且称之为`CF`

目前我们的加法器已经具备7种指令，看起来不错，不过还有存在一些不足：指令的位置必须和操作数的位置保持一致【电路设计上两者使用相同的地址线】

目前的指令执行方式无法调整操作数据的地址，这个设计让一些操作很难实现，我们希望指令可以操作任意内存地址上的数据。

举例来说，有些数据可能在运算过程中得到，比如我们先进行一个求和操作得到结果a并存储，然后计算其他操作，之后在另一个操作中需要使用a，这个时候如果不能指定地址获取数据，就不能获取数据a。

因此，我们需要对当前的自动加法器进行改进，思路很简单：指令和数据不再同步地址，指令可以指定地址。

## 改造自动加法器-指定地址
首先回顾下我们现有的7个操作：

|         操作码          | 代码  |
|:--------------------:|-----|
|       Load（加载）       | 10h |
|      Store（保存）       | 11h |
|       Add（相加）        | 20h |
|     Subtract（减法）     | 21h |
|    Add with Carry    | 22h |
| Subtract with Borrow | 23h |
|       Halt（停止）       | FFh |

改进之后的加法器，我们希望除了`Halt`指令依旧只占用1个字节，其他指令会占用3个字节：1个字节是操作码，2个字节是操作数据的地址。

实现该设计的关键：
1. 将代码RAM阵列的数据输出到3个8位锁存器中
2. 每个锁存器保存3字节指令的一个字节
3. 第1个锁存器保存指令代码本身
4. 第2个锁存器保存地址的高字节
5. 第3个锁存器保存地址的低字节

![可指定地址的加法器](https://pic.imgdb.cn/item/61f214ac2ab3f51d9164b96f.jpg)

我们可以看到，现在代码RAM阵列输出的第二个和第三个锁存器构成了数据RAM阵列的16位地址。

1. 【取指令（instruction fetch）】从存储器中取出指令的过程
2. 【执行（execute）】及其响应指令执行一系列操作的过程

我们改进设计后加法的使用更加灵活，代价是运算速度的下降。

使用地址获取数据后，不再需要将代码RAM和数据RAM分开，

# 遗留问题
- `Halt`指令是怎么实现的？

# 名词
- **累加器**：用来累加多个数的锁存器