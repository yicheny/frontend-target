[TOC]

# 多位锁存器
首先回顾下D型电平触发器：

![D型触发器-Clock](https://pic.imgdb.cn/item/618ca3742ab3f51d91539257.jpg)

之前我们使用Q和Q反两个输出，本章我们仅使用一种输出——目的是保存1位。

基于此保存的目的，我们将输入和输出端重新命名，使名称和功能相符：

![D型触发器-1位存储器](https://pic.imgdb.cn/item/61ebf88c2ab3f51d911f0a0b.jpg)

- 现在时钟端我们称之为 写操作端【Write】
- 数据端我们叫做 数据输入端【Data In】
- Q输出被叫做 数据输出端【Data Out】
- 使用电路记录信息叫做 写入【Written Into】 或 存储【Stored】 到电路中

> 这种类型的电路也被叫做锁存器，因为存储进去的数据好像被锁住一样。

1位锁存器示意图：

![1位锁存器](https://pic.imgdb.cn/item/61ebfa372ab3f51d9120cfb4.jpg)

实现多位锁存器很简单，就是将写操作端的信号连接到系统中【使用1个输入控制多个锁存器的写操作端】，如下图：

![多位锁存器-电路](https://pic.imgdb.cn/item/61ebfb502ab3f51d912211ae.jpg![img.png](img.png))

同样，我们以框图形式表现多位锁存器：

![多位锁存器-框图](https://pic.imgdb.cn/item/61ebfb782ab3f51d91223a28.jpg)

为了方便表示，我们也可以使用简写图：

![多位锁存器-简写图](https://pic.imgdb.cn/item/61ebfbfb2ab3f51d9122c480.jpg)

## 另一种集成多位锁存器的方式
在某些场景下，我们会使用另一种方式集成多位寄存器，它的结构不像上面那么简单，但是可以满足一些上面不能满足的需求。

需求：
1. 我们只想用一个数据输入和输出信号端
2. 希望锁存器能将输入信号数据分8次独立存储
3. 这个任务可以在长达1天内完成，也可能在下一秒搞定
4. 最后我们希望可以通过 观察数据输出信号端 确定实际的8位输出

简而言之：在这种锁存器里我们只想存储8个单独的比特，而不是1个8位二进制数【就是说，我们不需要一次展示所有比特，而是可以按顺序输出8位比特】

为什么会出现这种需求？

原因在于只有一个灯泡【输出】！

分析下现在的情况：存储8个比特，肯定需要8个1位存储器，先不考虑数据如何存储。关键在于：如何用一个灯泡来确定锁存器的数据输出信号，我们必须先确定预期的效果。

最简单粗暴的方式就是依次将灯泡连接在每个锁存器上，分若干次记录各个锁存器的输出。

不过这个方式想一想也能感受到麻烦：
1. 需要重复性的进行电路连接操作
2. 需要重复性的进行测试输出

我们追求更加自动化的方法。

进一步，我们首先解决第一个问题：重复性的电路连接，使用开关我们可以避免重复连接。

即：我们使用开关来决定测试哪一个寄存器。

最直接的想法是对每个锁存器使用一个开关，不过这不是一个好主意，我们并不需要使用这么多开关，太多的开关反而使得出错的可能增加【比如多个开关同时连接可能造成异常】

将这个问题进一步抽象，现在的问题是：怎么从8个物体中选择一个我们想要的？

实际上，我们只需要3个开关就可以实现对8个锁存器的选择，因为3bit可以表示`2^3=8`种情况。

目前我们准备的工具：
1. 8个1位锁存器
2. 3个开关
3. 1个灯泡

我们预期的效果：

![测试器-预期](https://pic.imgdb.cn/item/61ed4f732ab3f51d9152d2f5.jpg)

现在的关键是：我们怎么实现这个选择器？

### `8-1`选择器
在第十四章我们实现过一个`2-1`选择器，在手动输入和锁存器输入中进行选择，我们现在需要实现的是`8-1`选择器：

![8-1选择](https://pic.imgdb.cn/item/61edf8dd2ab3f51d91dc87ff.jpg)

`8-1`选择器有8个数据输入，3个选择输入，根据选择输入我们决定选择使用哪个数据输入。

| 选择输入       | 测试的数据输入 | 
|------------|---------|
| s2,s1,s0 | Q |
| 0,0,0      | D0      | 
| 0,0,1 | D1 |
| 0,1,0 | D2 |
| 0,1,1 | D3 |
| 1,0,0 | D4 |
| 1,0,1 | D5 |
| 1,1,0 | D6 |
| 1,1,1 | D7 |

`8-1`选择器电路实现如下，主要部件有：
1. 三个反向器
2. 八个4端口输入与门
3. 一个8端口输入或门

![`8-1`选择器电路](https://pic.imgdb.cn/item/61edfa832ab3f51d91dd9ed9.jpg)

这个线路看上去密密麻麻的，很复杂的样子，但是想要理解其工作原理，我们只需要一步步分析即可。

我们以选择器`0,0,0`的状态为例，观察数据端输入与输出的情况：
- D0与门的输入是`1,1,1,X`，则无论输入什么，D0与门的输出都与D0完全保持一致
- D1有S0输入0，则输出必为0
- D2有S1输入0，则输出必为0
- D3有S0、S1输入0，则输出必为0
- D4有S2输入0，则输出必为0
- D5有S0、S2输入0，则输出必为0
- D6有S1、S2输入0，则输出必为0
- D7有S0、S1、S2输入0，则输出必为0
- 综上，选择器输入`0,0,0`，则输出和D0输入保持一致

其他情况下的选择器输入也是类似的分析。

或者也可以换个角度，从单个选择器输入影响角度进行观察
- S0为0，则D1、D3、D5、D7输出必为0
- S0为1，则D0、D2、D4、D6输出必为0
- S1为0，则D2、D3、D6、D7输出必为0
- S1为1，则D0、D1、D4、D5输出必为0
- S2为0，则D4、D5、D6、D7输出必为0
- S2为1，则D0、D1、D2、D3输出必为0

假设我们想输出D6，依次向上，避开D6为0的情况既可，则得到的选择器输入是`1,1,0`【S2,S1,S0】，可以发现和我们上面的选择表是一致的。

从这个角度可以很简单的知道电路的选择逻辑。

让我们重新看下现在的测试器组成：

![测试器](https://pic.imgdb.cn/item/61ee32d52ab3f51d910f3f19.jpg)

目前测试器支持的功能：
1. 支持8个输入
2. 通过选择器可以选择其中1个输入
3. 输出信号可以鉴别数据

输出端已经满足需求，现在我们进一步考虑输入端。

1. 之前我们是将写操作直接和所有数据输入连接的，但是现在不能这么做。
2. 因为现在我们很可能想对某个锁存器独立的进行写入。
3. 所以我们需要一个独立的写入信号，它能被路由到任意（且唯一）的锁存器上

系统的预期结果如下图所示：

![输入路由器-预期](https://pic.imgdb.cn/item/61ee619c2ab3f51d91404640.jpg)

为了实现路由功能，我们需要另一款电路元件，这款元件和`8-1`选择器类似，但是作用却相反，它就是**3-8译码器**

### `3-8`译码器
`3-8`译码器，顾名思义有3个输入，8个输入，关键在于：**在任何时刻，译码器只会有一个输出为1**

我们来看下译码器的电路连接：

![3-8译码器实现](https://pic.imgdb.cn/item/61ee62c22ab3f51d9141921e.jpg)

> 注意观察，这次的电路和`8-1`选择器非常像

从输入角度分析下：
- S0为0，则O1、O3、O5、O7输出必为0
- S0为1，则O0、O2、O4、O6输出必为0
- S1为0，则O2、O3、O6、O7输出必为0
- S1为1，则O0、O1、O4、O5输出必为0
- S2为0，则O4、O5、O6、O7输出必为0
- S2为1，则O0、O1、O2、O3输出必为0

假设我们想将数据输出到`O6`，依次向上，避开`O6`为0的情况既可，则得到的选择器输入是`1,1,0`【S2,S1,S0】，可以发现和我们上面的选择表是一致的。

> 其实这里我直接把`8-1`选择器的分析拿过来了，同样适用

我们反向类推下，可以得到这么一份表：

|  数据输出端  | 输入【S2->S0】 | 
|:-------:|------------|
|   O0    | 0,0,0      |
|   O1    | 0,0,1      |
|   O2    | 0,1,0      |
|   O3    | 0,1,1      |
|   O4    | 1,0,0      |
|   O5    | 1,0,1      |
|   O6    | 1,1,0      |
|   O7    | 1,1,1      |

或者我们可以使用选择器为起点，观察输出情况：

| 输入【S2->S0】  |  数据输出端【O7->O0】   |
|:-----------:|:----------------:|
|    0,0,0    | 0,0,0,0,0,0,0,X  |
|    0,0,1    | 0,0,0,0,0,0,X,0  |
|    0,1,0    | 0,0,0,0,0,X,0,0  |
|    0,1,1    | 0,0,0,0,X,0,0,0  |
|    1,0,0    | 0,0,0,X,0,0,0,0  |
|    1,0,1    | 0,0,X,0,0,0,0,0  |
|    1,1,0    | 0,X,0,0,0,0,0,0  |
|    1,1,1    | X,0,0,0,0,0,0,0  |

### RAM
完整测试器如下：

![完整测试器](https://pic.imgdb.cn/item/61ee65f52ab3f51d9144c870.jpg)

值得注意的是：译码器和选择器具有相同的选择信号，在上图中这三个信号一起被称为地址端口（Address）。

地址的作用就像QQ号或邮箱号，长度为3位的地址了8位锁存器中的哪一个将被引用。
- `3-8`译码器中，地址起到了决定哪些锁存器可以被写操作端信号触发来保存数据的作用。
- `8-1`选择器中，通过地址选择输出8个锁存器其中一个的信号

这种配置下的锁存器在有的资料中也被称作”读/写存储器“（read/write memory），更普遍的叫法是**随机访问存储器**（Random Access Memory），简称`RAM`

可以认为我们讨论的这种存储器是可存储8个独立比特的RAM，它的简化结构图如下：

![8bitRAM](https://pic.imgdb.cn/item/61ee686f2ab3f51d91475bb3.jpg)

1. 这个电路之所以可以被称作存储器是因为它可以保存信息
2. 而能够被称为读/写存储器是因为它不仅可以在每个锁存器中存储器新的数据【这种功能称为写数据】，我们还可以检查每个锁存器保存了什么数据【这种功能称为读数据】
3. 之所以可以被称为随机访问存储器，是因为读写操作很自由，我们只需要改变地址及其相关的输入，就可以从8个锁存器中读出或写入需要的数据。相比于其他的顺序型存储器——这种存储器在使用时有一定限制，想要读取地址101的地址，则必须先读取地址100的数据

# RAM阵列（Array）
将RAM进行特殊的配置可形成RAM阵列（Array），我们所讨论的这种RAM阵列以8x1的方式组织起来。阵列以1比特作为存储单位，共存储8个单位的数据，所以这个RAM阵列中能存储的位数等于8和1的乘积。

## `8x2`阵列
RAM阵列的组合形式多种多样，比如我们可以通过共享地址的方式将两个8x1的RAM阵列连接起来，如下图：

![8x1共享地址](https://pic.imgdb.cn/item/61ee6bc92ab3f51d914af926.jpg)

我们将两个8x1的RAM阵列的地址和输出看作一个整体，这样就得到了一个8x2的RAM阵列，如下图：

![8x2阵列](https://pic.imgdb.cn/item/61ee6cdf2ab3f51d914bfbf3.jpg)

这个RAM阵列可存储的二进制数仍然是8个，但是每个数的位宽是2bit

## `16x1`阵列
我们也可以将两个`8x1`RAM阵列看作两个锁存器，使用一个`2-1`选择器和`1-2`译码器就可以将它们按照单个锁存器的方式集成。

这个方案的电路图如下：

![16x1阵列](https://pic.imgdb.cn/item/61ee6da72ab3f51d914cad2c.jpg)

注意：这里新加的选择端连接的是译码器和选择器，作用在于选择哪一个RAM阵列，我们可以将其是做第4根地址线。

这种连接得到的是一种`16x1`的RAM阵列，如下图：

![16x1阵列](https://pic.imgdb.cn/item/61ee6ede2ab3f51d914dc328.jpg)

这个RAM阵列容量为16个单位，每个单位占1bit

## 存储容量
RAM的存储容量与其地址端数量有直接联系
1. 没有地址输入端，只能存储1个单位的数据
2. 1个地址输入端，可以存储2单位数据
3. 2个地址输入端，可以存储4单位数据
4. ...

容量和地址端数量的关系可以归纳如下：
```
RAM阵列的存储容量 = 2^地址输入端的个数![img.png](img.png)
```

简单来说，地址端加1，RAM阵列的容量翻倍。

假设我们构建了一个有10地址端的大规模RAM阵列，如下图：

![2^10地址](https://pic.imgdb.cn/item/61ee72262ab3f51d9150b69b.jpg)

这个阵列可以存储1024个单位数据，每个单位8bit，一共可以存储8192bit信息

我们知道`1byte = 8bit`，这里正好是`1024byte`，称作`1KB`。

限制我们已经学会构造任意大小的RAM阵列，假设限制构造好了一个容量位65536字节的存储器组织，如图：

![2^16地址](https://pic.imgdb.cn/item/61ee739d2ab3f51d915217a1.jpg)

为什么选择`64KB`，而不是`32KB`或`128KB`？

因为`65536`是`2^16`，这个容量的出现是因为我们选择配备16位的寻址端。

进一步，为什么选择16位地址段？因为该地址恰好可以用两个字节标识，地址范围转换为16进制就是`0000h~FFFFh`

# 控制面板
至此，我们构建的电路已然非常复杂，需要数量庞大的继电器支撑。

简单分析下，在我们的电路设计中，存储每个比特需要9个继电器，则64K*8的RAM需要：`65536*8*9=4718520`，约500万继电器实现——实际上现代计算机并没有使用继电器进行实现。

虽然使用的电子元件数量庞大，不过对于使用者而言并不会很复杂——只需要借助控制面板。

我们来设计这个控制面板，看一下我们需要哪些功能和开关：
1. 地址端输入：用于定位数据
2. 数据输入：用于写入
3. 写入开关：用于控制读写模式

实现以上功能，对我而言已经是很不错的控制面板了，不过这里我还会加上一个功能：
1. 控制开关：一旦启动这个开关，则存储器可以由外部电路控制，此时控制面板上的其他开关将不起任何作用。

让我们来看一下这个控制面板：

![控制面板](https://pic.imgdb.cn/item/61ee8f8c2ab3f51d916aafb6.jpg)

其他功能暂且不提，我们考虑下实现控制开关需要什么？

需要25个`2-1`选择器：
- 16个控制地址输入端
- 8个控制数据输入端
- 1个控制写操作端

控制功能电路图：

![控制功能](https://pic.imgdb.cn/item/61ee90152ab3f51d916b322a.jpg)

1. 当控制端断开时，所有信号来源于控制面板开关
2. 当控制端闭合时，所有信号来源于外部电路

64KB*8RAM阵列的逻辑框图：

![逻辑框图](https://pic.imgdb.cn/item/61ee91802ab3f51d916c9914.jpg)

另外注意一下，这里我们使用8个灯泡作为输出，实际上这个输出当然也可以作为其他电路的输入。

通过与其他电路连接，我们可以实现更强大更复杂的功能。