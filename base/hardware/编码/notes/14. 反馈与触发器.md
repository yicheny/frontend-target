[TOC]

# 振荡器
我们来看一段电路：

![](https://pic.imgdb.cn/item/61892b822ab3f51d91af7b88.jpg)

这个电路乍看之下有些怪，通常我们见到的继电器，输入和输出是分开的，而这里却构成了回路。

我们将开关闭合，电路连通：

![](https://pic.imgdb.cn/item/61892c132ab3f51d91afe7f4.jpg)

电路连通，电磁铁获得磁性，将金属簧片拉下：

![](https://pic.imgdb.cn/item/61892c562ab3f51d91b0162f.jpg)

金属片拉下，电路不再连通，电磁铁不再具有次磁性，金属片弹回原位：

![](https://pic.imgdb.cn/item/61892c132ab3f51d91afe7f4.jpg)

这样，电路又一次连通了，又回到初始的情况。

这个电路可以简化成如下符号符号表示：

![](https://pic.imgdb.cn/item/61892d492ab3f51d91b0c997.jpg)

开关也可以省去：

![振荡器](https://pic.imgdb.cn/item/61892d772ab3f51d91b0eb4f.jpg)

这幅图看起来很矛盾：
1. 输入和输出相反
1. 输出即输出！

但是我们回到电路底层，这一切就变的可以理解了。

首先这里信息变换是使用反向器实现的，我们知道反向器本质上是继电器，继电器信号变换是需要一点点时间的，所以这里输入和其相反的输出信号不是同步得到的，变化是**需要时间的**。

也正是因此，才能做到信号持续的反复变化。

电路的输出是什么？是提供电压，或不提供。我们可以使用另一种方式描述这种情况，用0、1表示有无电压。

这种电路我们称为振荡器（信号会自动循环交替）

振荡器和我们之前所学的东西存在本质区别：之前的所有电路，其状态的改变都依靠人为干预，通常是通过改变开关状态实现的，而振荡器却在不需要人干涉的情况下进行改变

> 继电器的意义：是使用电流而非人为控制的开关。

实际上，振荡器是继电器的一个特殊使用场景，使用振荡器我们可以实现自动控制系统（在之后的章节中）

我们使用0、1表示振荡器输入，用图形描述如下：

![](https://pic.imgdb.cn/item/618a3b622ab3f51d916b124a.jpg)

注意这幅图，随着时间变化，振荡器的输出在0、1之间按规律交替进行变化，因此振荡器又被称为**时钟**，通过振荡器进行计数是一种计时方式。

振荡器从某个初始状态开始，经过一段时间回到初始状态的这个间隔被定义为振荡器的一个**循环**，或者称为一个**周期**

![](https://pic.imgdb.cn/item/618a3c062ab3f51d916c19e4.jpg)

一个循环所占用的时间就是该震荡的周期，周期的倒数是**频率**。

假设某个振荡器周期是`0.05s`，那么频率就是`1/0.05=20`，即每秒的循环次数

频率的单位是`Hz`，来源于发送和接收无线电波的第一人——【亨利希-鲁道夫-赫兹】，表示每秒循环次数。

如果我们说这个振荡器的频率是20Hz，就是说这个振荡器状态交替每秒循环20次

到目前为止，对于振荡器的速度都只是猜测，在本文的最后我们将构建一种可以测量振荡器速度的元件。

# 可以记住输入的电路
我们先看下或非门【NOR】运算表：

| 输入  | 输出 |
|-----| --- |
| 0,0 | 1 |
| 0,1 | 0 |
| 1,0 | 0 |
| 1,1 | 0 |
从表里我们知道，只有两个输入端都没有电压时，输出端才产生电压。

> 如果记不住，可以通过公式 1-(A*B) 推算结果

我们来看一个特别的电路：

![](https://pic.imgdb.cn/item/618a40862ab3f51d91731518.jpg)

这个电路特殊在回环的导线，因为这个连线，两个或非门的输出互为输入，这种连接方式我们称为**反馈**

初始状态下：
1. 左侧或非门，输入为0、0，输出1
2. 右侧或非门，输入为0、1，输出0 => 灯泡熄灭

我们将上面的开关闭合，效果如下：

![](https://pic.imgdb.cn/item/618a41a62ab3f51d9174d5ae.jpg)

此时状态：
1. 左侧或非门，输入为0、1，输出0
2. 右侧或门非，输入为0、0，输出1 => 灯泡亮

接下来，我们断开上面的开关，可以发现灯泡依旧闪亮

![](https://pic.imgdb.cn/item/618a42082ab3f51d91756ae3.jpg)

分析下此时状态：
1. 左侧输入为1、0，输出0 
2. 右侧输入为0、0，输出1 => 灯泡亮

原因是因为右侧输出为1，而右侧输出为左侧输入，所以左侧输出必为0。

这里是不是很奇怪？现在的开关状态和初始状态是一致的，为什么灯泡状态不同？

让我们继续实验。

我们将下面的开关闭合：

![](https://pic.imgdb.cn/item/618a43452ab3f51d91773f83.jpg)

分析下此时状态：
1. 左侧输入1、0，输出0
2. 右侧输入0、1，输出0 => 灯泡灭

我们再断开下面的开关：

![](https://pic.imgdb.cn/item/618a40862ab3f51d91731518.jpg)

可以发现这个时候灯泡和初始状态一样熄灭了。

分析此时状态：
1. 左侧输入0、0，输出1
2. 右侧输入1、0，输入0 => 灯泡灭

这个电路特殊在：同样是两个开关断开的情况下，灯泡有时亮有时不亮。

这种具有两种稳定态的电路，被统称为**触发器**

我们可以通过灯泡的状态知道上一次闭合的开关是哪一个，灯泡亮，则上一次闭合的是上面的开关；灯泡熄灭，则上一次闭合的是下面的开关

这一点很重要，这意味着这个电路可以**记住**上一次的输入【准确的说是可以根据当前输出推导出上一次的输入】

在此之前，电路的状态只有“现在”，只有“现在”的电路无法抵达“未来”。

所谓“记忆”，是已发生事物的集合，发生在“过去”，我们通过“过去”递推至“现在”，只有“现在”我们无法递推至“未来”。

举一个例子，假设我们在数数，如果我们不记得上一次数的数，我们怎么知道这一次数到多少？又怎么知道下一次应该数多少？

人类将记住的事情称之为“记忆”，现在，我们将电路记住的事物称之为“数据”。

数据特性：
- 数据可以作为输入，但数据并不是输入【输入并不一定需要“记住”】
- 数据可变，但是如果我们不主动更新数据，它就是稳定不变的

# `R-S`触发器
触发器有很多，刚刚所说的是最简单的一种，叫做`R-S`（Reset-Set 复位/置位）触发器

我们可以用如下方式简写：

![](https://pic.imgdb.cn/item/618be3562ab3f51d91137479.jpg)

说明下符号的意义：
- `Q` 输出状态
- `Q反` 对`Q`的取反
- `R` 复位，将`Q`设为`0` 【对应先前触发器的下面开关】
- `S` 置位，将`Q`设为`1` 【对应先前触发器的下面开关】

我们用表总结下：
> 这类表叫做功能表(function table)、逻辑表、真值表，用于表达不同输入组合对应的输出结果

| S   | R | Q | Q反 | 
|-----| --- | --- | --- |
| 0   | 1 | 0 | 1 |
| 1   | 0 | 1 | 0 |
| 0   | 0 | Q | Q反 | 
| 1   | 1 | 禁止 | 禁止 |

特别说明下当`R`、`S`均为1的情况，可以看到表里我们写的是禁止，禁止的原因是当两者均为1时，`Q`和`Q反`输出均为0，这违反了我们一开始的定义。

设计`RS`触发器电路时，需要避免`R`、`S`同时为1。

`RS`触发器可以使用如下符号表示：

![](https://pic.imgdb.cn/item/618c64882ab3f51d913adf48.jpg)

# D型触发器
我们可以看到，`RS`触发器的能力是可以记住上一次哪一个输入为1，然而我们希望的是一种更强大的电路记忆能力：记住某个时间节点上的信号是0还是1

在真正设计这个电路之前，我们首先思考下它应该具备的能力（或者说它是通过什么形式进行记忆的】

1. 这个电路有两个输入端
2. 其中一个叫做数据端(Data)，用于输入信号
3. 另一个叫做保持位(Hold That Bit)，决定当前状态是否被“记忆”。通常状态保持位为0，此时数据端信号不会被记忆；保持位为1时，此时数据段信号会被记忆/保存到电路系统中。

真值表：

| 数据 | 保持位 | 输出  | 
| --- | --- |-----| 
| X | 1 | X   | 
| X | 0 | Q   |

我们只需要**在`RS`触发器上加两个与门**即可达成目的：

![D型触发器-RS](https://pic.imgdb.cn/item/618ca1292ab3f51d9152caeb.jpg)

我们只需要两个输入，而现在有三个输入。

复位和置位只需要一个输入【两者永远相反】，这样可以规避掉两者同时为1的情况，如图：

![D型触发器-Hold](https://pic.imgdb.cn/item/618ca2832ab3f51d91534169.jpg)

这个电路就是`D`型触发器，我们可以看到这个电路是符合我们一开始的需求的：
1. 两个输入
1. 数据端用于信号输入
1. 保持位为0，则数据端信号不会被记忆，保持位为1，记忆数据端信号。

不过在书中出现时这种电路时，**保持位通常被叫做时钟**。有些情况下它具备当作时钟的性质，可以在0、1之间有规律的变化，不过在这里，我们仅仅用于标识是否进行数据存储。

![D型触发器-Clock](https://pic.imgdb.cn/item/618ca3742ab3f51d91539257.jpg)

我们将数据端简写为`D`，时钟端简写为`Clk`，输出端简写为`Q`，更新功能表：

| D | Clk | Q | 
| --- | --- | --- | 
| X | 1 | X | 
| X | 0 | Q |

这个电路可以被叫做：
1. D型触发器
1. 电平触发的D型锁存器
1. 1位存储器

现在我们先不介绍如何将多个1位存储器连接构成多位存储器，在之后的章节会说明。

# 使用D型触发器改造加法器
## 8位锁存器
使用锁存器保存多个值很有用，我们可以使用8位寄存器保存加法器的计算结果：

![8位锁存器](https://pic.imgdb.cn/item/61ed60662ab3f51d9163a8e7.jpg)

1. 这个机器可以一次保存8位
2. 输入是加法器的计算结果
3. CLK为0，输入不影响保存数据
4. CLK为1，将计算结果保存

8位锁存器可以使用下面简化表示：

![8位锁存器-简图](https://pic.imgdb.cn/item/61ed60d42ab3f51d916423c3.jpg)

## 为加法添加保存功能
我们先回顾加法器：

![加法器](https://pic.imgdb.cn/item/61ed61192ab3f51d91646f00.jpg)

我们先思考下我们需要添加的功能
1. 有一个保存开关，决定是否保存结果
2. 对于加法器的一个输入端，可以选择手动输入或使用上一次的结果

如何对电路进行改造：
1. 将结果输出连接到8位锁存器，并设置一个开关决定是否保存
2. 将8位锁存器和1个输入端通过**2-1选择器**相连，提供开关决定使用其中一个

最后结果如下：

![加法器+锁存器](https://pic.imgdb.cn/item/61ed61842ab3f51d9164c848.jpg)

### 2-1选择器
这里我们关注下**2-1选择器**的电路实现，2-1选择器使用了8个如下电路实现：

![2-1选择器单项](https://pic.imgdb.cn/item/61ed639c2ab3f51d91670dd6.jpg)

电路很简单，由两个与门和一个或门组成，我们分析下这个电路
1. 选择端对A、B输入必相反
   1. 即选择器的两个输入必然是[0,1]或[1,0]
2. 与门规则是其中一个输入为0，则输出必为0
   1. 即只要选择端输入0，则与门输出必为0
3. 或门是其中一端输入为0，则输出和另一端的输入相同， 就是说：
   1. 如果A与门输入0，则最终输出和B与门相同【因为A与门输出为0，则可知B与门选择器输入必为1，则B与门的最终输出和B输入保持一致】
   2. 如果B与门输出0，则最终输出和A与门相同【原理同上】

以我刚刚列举的电路来说，
1. 如果选择端输入0，则B为0，最终使用A的输入
2. 如果选择端输入1，则A为0，最终使用B的输入

### 问题：丢失进位输出
仔细观察，我们会发现锁存器会丢失进位数据。

针对这个问题，一个可能的做法是：将加法器、锁存器、选择器的位数都设置成16位，或者比可能存在的最大和的位数大1位【这里不使用9位，是因为如果锁存器可以保存9位，那么理论最大和可以超过9位】

不过这个做法并不推荐，我们使用另一种方案： 移除第二个输入部分及选择器，为8位选择器增加清零功能

D型触发器实现清零非常简单，增加一个或门和清零信号即可。

![D型触发器-清零](https://pic.imgdb.cn/item/61ed68122ab3f51d916bd2a1.jpg)

我们看一下现在的加法器：

![累加器](https://pic.imgdb.cn/item/61ed685d2ab3f51d916c27e8.jpg)

注意现在的功能：
1. 相加【相当于使用上一次的结果进行累加】
2. 清零【清零后通过A输入再保存即可，我们只需要一个输入】

新的加法器设计上更简单，却同样实现了原有功能：
1. 累加使用相加功能
2. 简单相加配合清零即可实现

> 不过我感觉这个新设计没有解决进位丢失的问题啊……<br/> 
> 进位的问题17章会再处理

# 边沿触发的D型触发器
边沿触发器关键改造：
1. 两个D型触发器
2. 时钟端同时连接两级触发器
   1. 一级取反连接
   2. 二级直连

![边沿触发的D型触发器](https://pic.imgdb.cn/item/61ea6cc22ab3f51d91960f05.jpg)

1. 时钟端输入既控制着第一级`R-S`触发器，也控制着第二级
2. 时钟信号在第一级中进行了取反操作
3. 这意味着，除了当 时钟信号为`0`时保存数据【修改数据】之外，第一级`R-S`触发器和`D`型触发器原理完全一致
4. 第一级`R-S`触发器的输出是第二级`R-S`触发器的输入，并且时钟信号也是第二级`R-S`触发器的输入
   1. 时钟信号为0时，第一级`RS`触发器可以保存数据，但是第二级不能保存
   2. 时钟信号为1时，第二级`RS`触发器可以保存数据，但是第一级不能保存
   3. 值得注意的是第一级触发通过继电器进行信号传输给第二级，而时钟信号直接通过导线传输给第二级
   4. 这意味着，时钟信号先于第一级触发器输出发生变化
   5. 那么，在时钟信号`0->1`时，第二级`RS`触发器先接收到这个输入，此时第一级触发器输出尚未改变，直到第一级输出改变之前这段期间，是可以保存数据的
   6. 就是说，这是第一级和第二级触发器都可以保存数据的时机
5. 总结而言，只有当信号由0变为1时，数据端输入才会被保存

# 分频器
我们回忆下开始“振荡器”，它的输出始终在`0`到`1`之间变化：

![振荡器](https://pic.imgdb.cn/item/61892d772ab3f51d91b0eb4f.jpg)

对原有的边沿触发器进行改造：
1. 我们将振荡器连接到触发器上，作为时钟端使用。
2. 我们将Q反的输出作为D端的输入

![振荡器接边沿触发器](https://pic.imgdb.cn/item/61eb8bcb2ab3f51d91ac25e1.jpg)

1. 这里触发器的输出同时也是它自己的输入
2. 振荡器是由 状态来回迅速改变的继电器 构成的
3. 其输出与构成触发器的继电器相连
4. 如果触发器的继电器和振荡器继电器相同，或快于振荡器继电器，则数据的存储会出现异常
   1. 首先，时钟端是用于决定是否保存数据的
   2. 数据端是输入数据的部分
   3. 时钟端变化`0 -> 1 -> 0 -> 1 ->...`至少要保证时钟端两次变化大于等于一次数据端输入变化，才能保证将数据输入全部保存【因为`0->1`再次出现状态至少要变化两次】
5. 为了避免以上问题，这里假设振荡器的继电器比电路中其他继电器速度要慢得多

## 追踪变化
| D   | CLK  | Q   | Q反 |
|-----|:----:|-----| --- |
| 1   |  0   | 0   | 1 |
| 1   | 0->1 | 1   | 0 |
| 0 | 1 | 1 | 0 |
| 0 | 1->0 | 1 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 0->1 | 0 | 1 |
| 1 | 1 | 0 | 1 |

1. 电路启动时，假设时钟输入为0，且Q输出也为0，则Q反为1，Q反和D端输入相连
2. 当 时钟输入从`0->1`时，
   1. 二级触发器可以进行数据保存
   2. D为1
   3. Q为1【数据变化】
   4. Q反为0
   5. D为0
3. 时钟完成输入1
   1. 二级触发器不受数据端输入影响
   2. D为0
   3. Q为1【数据稳定】
   4. Q反为0
4. 时钟输入`1->0`，数据不变
5. 数据完成输入`0`，数据不变
6. 时钟端再次输入`0->1`
   1. 二级触发器可以进行数据保存
   2. D为0
   3. Q为0【数据变化】
   4. Q反为1
   5. D为1
7. 时钟完成输入1
   6. 二级触发器不受数据端输入影响
   7. D为1
   8. Q为0【数据稳定】
   9. Q反为1

以上过程可以简单总结为：每当时钟输入由`0->1`时，Q端输出【保存数据】就发生变化  

时序图变化如下：

![时序图](https://pic.imgdb.cn/item/61eb9b242ab3f51d91bc6e53.jpg
)

- 当CLK输入`0->1`时，D值会被输出到Q保存，Q反和Q改变【取反】
- 下一次CLK`0->1`时，D值会被保存到Q保存，Q反和Q改变【取反】
  - 区别在于：每一次D值的输入必然和上一次输入是相反的！
  
如果这个振荡器的频率是`20Hz`（即20个周期的时间为1s），那么Q的输出频率是它的一半，即`10Hz`，由于这个原因，这种电路称作**分频器**，它的Q反输出反馈到触发器的数据端输入D

分频器的输出可以作为另一个分频器的`CLK`输入，以此再次进行分频，以下是3个分频器连接的示意图

![3个分频器](https://pic.imgdb.cn/item/61eb9d7f2ab3f51d91bee691.jpg)

以上3个分频器信号变化规律如下图：

![3个分频器信号变化规律](https://pic.imgdb.cn/item/61eb9e8b2ab3f51d91c047e1.jpg)

实际上这只是信号变化的一小部分，整个电路会重复以上过程周而复始的变化。

观察这幅图，我们可以发现什么？

提示：可以将信号表上0和1，如下图：

![3个分频器信号变化01标记](https://pic.imgdb.cn/item/61eb9f3c2ab3f51d91c10789.jpg)

从上到下，从左向右阅读，我们会发现每一列的4个数字，正好对应了十进制的`0-15`

我们发现，这个电路已经具备了计数功能，每一次时钟信号`0->1`【正跳变】时，计数器输出递增1

如果在这个电路中添加更多的触发器，就可以进行更大返回的计数， 每增加一个分频器，计数范围就翻倍一次。

我们在将8个触发器连接在一起，放到一个盒子里，就构成了一个8位计数器：

![8位计数器](https://pic.imgdb.cn/item/61eba1482ab3f51d91c32a5f.jpg)

这个计数器称作**8位行波计数器**，因为每一个触发器的输出都是下一个触发器的时钟输入。变化是在触发器中一级一级的顺序传递的，最后一级触发器的变化必定会有一些延迟，更先进的计数器是**并行（同步）计数器**，这种计数器的所有输出是在同一时刻改变的。

在计数器中输出端用`Q0~Q7`标记，最右边`Q0`是第一个触发器的输出，如果我们将灯泡连接到这些输出端上，就可以将8位数字读出来。

这样一个计数器的时序图可以将8个输出分别表示出来，也可以将它们作为一个整齐一起表示，如下图：

![计数器输出时序图](https://pic.imgdb.cn/item/61eba27c2ab3f51d91c4745a.jpg)

## 计算振荡器频率
以8位计数器为例
1. 将计数器的8个输入端分别接道8个灯泡上
2. 在所有输出都为0时（即所有灯泡都熄灭），启动秒表计时
3. 当所有输入都为1时（即所有灯泡都点亮），停止秒表计时
4. 8位计数器一次循环会进行256次输出，即振荡器进行了256次循环
5. 计时/循环次数即可得到振荡器频率，假设计时为`10s`，则振荡器频率为`256/10=25.6Hz`

# 为边沿D触发器添加"预置"和”清零功能“
![带预置和清零功能的触发器](https://pic.imgdb.cn/item/61eba8372ab3f51d91cb123e.jpg)

状态变化如表所示：

| Pre | Clr | D   | CLK  | Q   | Q反  |
|-----|-----|-----|------|-----|-----|
| 1   | 0   | X   | X    | 1   | 0   |
| 0   | 1   | X   | X    | 0   | 1   |
| 0   | 0   | 0   | 0->1 | 0   | 1   |
| 0   | 0   | 1   | 0->1 | 1   | 0   |
| 0   | 0   | X   | 0    | Q   | Q反  |

1. 预置和清零信号输入会覆盖时钟和数据端输入
2. 当预置信号为1时，Q为1，Q反为0
3. 当清零信号为1时，Q为0，Q反为1
4. 预置和清零信号同时为0时，以普通边沿D触发器工作模式工作
5. 预置和清零信号不能同时为1

电路图符号可以使用下图简化：

![示意图](https://pic.imgdb.cn/item/61ebabb52ab3f51d91cf0ef5.jpg)

至此，我们已经可以使用继电器实现加法、减法和计数了。

# 名词
- **触发器**：具有两种稳定态的电路
- **反馈**：指把输出电路中的部分能量送回输入电路中，以增强或减弱输入信号的效应。起增强作用的反馈叫正反馈，起减弱作用的反馈叫负反馈。
- **锁存**：把信号暂存以维持某种电平状态
- **锁存器**：是数字电路中 异步时序逻辑电路系统中 用来储存信息的一种电子电路，一个锁存器可以存储1bit信息

# 资料
- [wiki-触发器](https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8)