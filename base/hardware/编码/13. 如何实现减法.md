[TOC]

# 十进制减法
首先看一个减法运算：
```
  253
- 176
=  77
```

我们通用的减法使用的是“借位”机制，这是一个很麻烦的机制，我们设计电路会绕开这个机制实现减法。

## 求补
标准减法公式：`被减数 - 减数 = 差`

### 减数求补
我先用一个例子演示补位机制：求`253-176`的差

1. 求`176`的补数得`823`【每位拿9对减】
2. `253+823=1076`
3. `1076+1=1077`
4. 去除最高位`1`，结果是`77`

分别说一下这几步得意义：
1. 相当于`999-176=823`
2. `253+823=1076`
3. `1076+1=1077`
4.  相当于`1077-1000=77`

我们将以上运算综合起来看一下：
```
253 - 176
= 253 - (176 + 1000 - 1000)
= 253 - (176 + 1000 - 999 -1)
= 253 + (999 + 1 - 176 -1000) //注意符号变化
= 253 + (999 - 176 + 1 - 1000)
= 253 + (823 + 1 - 1000)
= (253 + 823 +1) - 1000
= 1077 - 1000
= 77
```

### 被减数求补
我们也可以对被减数补码得到结果。

1. `253`补码得到`746`
2. `746+176=922`
3. `922`补码得到`77` 

推导过程：
```
253 - 176
= (999-999) + (253 - 176)
= 999 - 999 + 253 - 176
= 999 - (999 - 253 + 176) //注意这一步变换
= 999 - ((999 - 253) + 176) 
= 999 - (746 + 176)
= 999 - 922
= 77
```

以上两种方式都可以避开借位机制。

第二种方式是帕斯卡计算机使用的补码方式。

我们现在使用第一种方式进行电路设计。

不过在此之前，我需要说一下被减数小于减数的情况。

## 负数
被减数小于减数，结果为负。

```
176-253
= 176 + 746 + 1 - 1000
= 922 - 999
= -77
```

我们是怎么得到`-77`的？

分成两步：
1. 减数被减数互换，`999-922`得`77`
2. 加负号，得到`-77`

# 二进制
二进制运算与十进制运算并无本质不同。

不过，二进制求补更简单，因为二进制只有`0`、`1`，所以不需要使用减法，直接将`0`、`1`互换即相当于求补。

因此，二进制求补也被叫做求相反数或反码。

我们在之前已经了解到，使用反向器可以实现这个目的。

## 二进制运算流程
> 注：CP表示求反操作

和十进制类似的运算流程。

结果为正的运算流程：
``` 
=> 253-176
   11111101(253)  
-  10110000(176)

=> 减数取反
   01001111(79)

=> 被减数 + 减数反码
    11111101(253)
    01001111(79)
=  101001100(332)

=> +1
  1010001100(332)
+ 0000000001(1)
= 1010001101(333)

=> 移除最高位1
0010001101(77) //注意，这里我们将最高位作为符号位，0表示正数
```

对于结果为负数的运算流程：
``` 
  10110000(176)
- 11111101(253)  

=> 被减数 + 减数反码
   10110000(176)
+  00000010(2)
= 010110010(178)

=> 取反
  CP(0100110010)
=    1011001101 //注意，这里我们将最高位作为符号位，1表示负数
```

## 电路设计
我们这次设计的不是一个纯粹的减法器【纯粹的减法器设计上更简单一些】，而是对原来的加法器改进电路，实现对减法的支持。

![控制面板](https://pic.imgdb.cn/item/6188a92a2ab3f51d91a75d86.jpg)

注意最高位的灯泡，加法的时候表示上溢（超过255），减法时用于表示下溢（负数）

减法器首先要做的是对输入取反【只对下方的输入取反】，使用反向器可以实现这个目的。

![](https://pic.imgdb.cn/item/6188aaf32ab3f51d91a8625d.jpg)

然后，这里我们希望只有做减法时取反，所以这里使用的不是反向器，而是**异或门**

电路图：

![](https://pic.imgdb.cn/item/6188ab812ab3f51d91a8bb87.jpg)

注意，这里的取反线用于对应减法的选择：
- 如果不是减法，取反线=0，输入即输出
- 如果是减法，取反线=1，输入输出相反

异或门运算表：
| XOR | 0 | 1 | 
| -- | -- | -- |
| 0 | 0 | 1 | 
| 1 | 1 | 0 |

这个电路叫做**求补器**，我们可以用如下方式简写（注意左侧的取反箭头）：

![](https://pic.imgdb.cn/item/6188ad272ab3f51d91a9995a.jpg)

我们现在回顾下整体电路的连接：

![](https://pic.imgdb.cn/item/6188ad7a2ab3f51d91a9cb74.jpg)

注意这个电路我们对三个地方使用了`SUB`，这个标识表示加/减法转换开关
1. 溢出标识
1. 输出
1. CI进位【默认为0，取反为1】

这里尤为需要说一下CI进位。

之前的运算流程里我们发现，负数运算是不需要+1的，直接取反即可。

我们现在的减法器CI默认为1，所以现在这个电路不支持结果为负的运算。

# 关于负数
在计算机领域，整数常用三种表示法
1. 无符号表示法
1. 符号加绝对值表示法
1. 二进制补码表示法

分别说一下。

## 无符号表示法
无符号表示法用于存储一些没有负数的情况，比如说从0开始的计数、寻址、文本、视频、图像等

## 符号加绝对值表示法
符号加绝对值表示法也很容易理解，就是将一个位作为符号位使用，这种表示并不用于表示数字整数，通常用于表示采样模拟信号，比如说音频

我们看一下如果4位二进制数的表示：
```
0000 0001 0010 0011 0100 0101 0110 0111 (+0到+7)
1000 1001 1010 1011 1100 1101 1110 1111 (-0到-7)
```
我们使用前半端表示正，后半段标识负。

其实这里还有一点很怪异，我们使用两个位表示`0`，这其实很怪，请问`+0`和`-0`是否相等？从数学上来说，两者是相等的，从二进制表示上来说，两者是不同的。

所以，符号加绝对值并不适合用于存储数学意义上的数。

另一个缺陷是，使得可以表示的范围相较于其他表示法少一位，因为`+0`和`-0`占据了两个位置。

## 补码表示法
二进制补码标识法，几乎所有计算机使用二进制补码表示法来来存储有符号整数。

通常意义下，我们将`0`作为正数和负数的终点，左右两侧是可以无限延伸的序列
```
...,-1000000,-999999,...,-3,-2,-1,0,1,2,3,...,999999,1000000
```

而实际的使用场景，或者计算机存储中，可以表示和存储的数字并不是无线的。

假设现在某个场景下我们需要表示的数字范围是-500到499之间，总共1000个数，且现在只能使用三位十进制数。

我们看一下常规表示：
```
-500,-499,-498,...,-3,-2,-1,0,1,2,3,...,497,498,499
```

我们改变下思路：
- 用`500`表示`-500`
- 用`501`表示`-498`
- 用`502`表示`-497`
- ……
- 用`998`表示`-2`
- 用`999`表示`-1`
- 用`0`表示`0`
- 用`1`表示`1`
- 用`2`表示`2`
- ……
- 用`497`表示`497`
- 用`498`表示`498`
- 用`499`表示`499`

可以想象这么一个序列表示：
```
500,501,502,...,997,998,999,0,1,2,3,...,497,498,499
```

这种序列表示有什么好处？

它形成了一个循环序列，最小的负数-500(500)看起来像是最大整数(499)的延续。而数字-1(999)，是比0小的第一个负数。如果我们在999上加1，通常会得到1000，由于我们处理的是三位数，这个结果对我们而言实际是`000`。

简而言之，这种表示法非常有利于运算。

这种标记法称为10的补数，我们可以将负数转换为10的补数。求补数就是**取反再+1**，比如说求-255对10的补数：
```
求-255对10的补数
=  999-255+1
=  744+1
=  745
```

二进制更简单一点（简单在取反上），如：
```
 CP(011111111) + 1
= 10000001
```
 
### 反码和补码
这里稍微提一下计算机中的两种运算：**补码**和**反码**

反码是 将每个位的`0`、`1`互换，如：
```
    00110101
=>  11001010
```

补码是 从右开始复制位，直到有1被复制，然后反转剩余的位，如：
```
    11001010
=>  00110110
```

刚刚我们补码表示法运算使用的是反码+1，使用补码可以直接得到结果：
```
    011111111
=>  100000001
```

### 优势
我们看一下8位二进制数使用补码表示法
- `10000000`
- `10000001`
- `10000010`
- ……
- `11111111`
- `00000000`
- `00000001`
- ……
- `01111101`
- `01111110`
- `01111111`

优势之一：可以很清楚的看出正数和负数，首位为0则是正，首位为1则是负

当然这个优势使用符号也绝对值表示法也一样。

二进制补码表示法真正强大的是在运算上，比如我们将`-127`和`124`等价的二进制数相加：

```
  10000001(-127)
  01111100(124)
= 11111101(-3)
```

## 二进制数
请问二进制数`10000001`相当于十进制的多少？

1. 无符号表示法 `129`
1. 符号加绝对值表示法 `-1`
1. 补码表示法 `-127`

所以回答这个问题之前，我们必须直到这个数字究竟是以何种表示法表示或者存储的。

这就是二进制数的麻烦之处，它们只是一些0和1，本身没有任何含义。