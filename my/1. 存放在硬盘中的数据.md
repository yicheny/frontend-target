[TOC]

主要介绍的是机械硬盘

从以下内容进行讲解：
1. 硬件构造
2. 分区格式
3. 文件系统
4. 磁盘阵列

# 硬件构造
![硬盘结构图](http://c.biancheng.net/uploads/allimg/181012/2-1Q012154JE59.jpg)

机械硬盘由哪些硬件组成：
1. 串行接口：电源+数据传输
   1. 控制线
   2. 地址线
   3. 数据线
2. 空气过滤片：保证腔体无尘。这里我们可以思考一个问题，为什么需要空气过滤片？它是用于保证腔体内无尘的，如果我们想要腔体无尘，直接封闭腔体，不让空气进入不行吗？是什么理由要让空气进入腔体内呢？答案是散热，磁盘运转过程中会有电能消耗释放出热能，所以可以看到磁盘体外会有一个呼吸腔用于交换空气进行散热
3. 盘片-磁性物质，磁性物质的结构是影响磁盘容量的重要因素
4. 主轴-电能马达，驱动盘体旋转
5. 磁头-通过释放不同电流来改变磁性物质性质 
   1. 写：发出电流改变磁性物质性质
   2. 读：磁性物质可以让磁头产生感应电流，经过相关电路处理后会被还原成数据
6. 音圈马达：驱动磁头旋转
7. 永磁铁-断电时可以保证磁头停留在停泊区
8. 磁头停泊区-同样需要思考一个问题？为什么需要永磁铁和磁头停泊区，断电时，让磁头直接停留在盘片上，通电时继续旋转不行吗？答案是不行的，因为实际上读写数据时磁头和盘片并没有接触，如果断电时磁头直接停留在盘面上，一则通电时会阻碍磁盘旋转，二则两者的摩擦粘连会使得磁头和盘面受到损伤，因此磁盘不工作时，磁头需要被放置在磁头停泊区。其实除了这种方案之外，还有一种方案，在磁盘盘面中会设置一个内部环形区域，用于停泊磁头，但是同样的会有摩擦损伤，所以这种方案对磁头启停次数是有限制的。目前来说，永磁铁+磁头停泊区是较为通用的方案。

## 盘区分隔

![](https://pic1.zhimg.com/80/v2-dc762f4e4037b261d0134171213c94a0_720w.jpg)

从大到小分别是：
1. 盘片：磁盘由数个盘片构成，之前我在论坛有看过相关的拆解图片，希捷7200转的机械硬盘盘片厚度小于1分钱，和DVD厚度类似，一般来说4个盘片是比较常见的。
2. 盘面：盘片分为正反两面，从第一个盘片的正面开始记作0面、1面……磁头和盘面编号是对应的
3. 柱面
   1. 所有盘面的统一磁道构成一个圆柱，通常称作柱面
   2. 数据读写按柱面进行，即磁头读写时首先从当前柱面的0磁头开始操作，依次向下在不同磁头上进行操作，只有柱面磁头全部读写完成后才转移到下一柱面
   3. 磁头切换是电子切换，而柱面切换是机械切换，所以速度差距极大
4. 磁道
   1. 盘面有许多同心圆，这些同心圆轨迹叫做磁道；
   2. 磁道从外向内从0开始编号
   3. 磁道宽度取决于磁头大小，磁头越小，则盘面不变的情况下可容纳越多的磁道
5. 扇区：数据存储的最小单位，一般是512B，随着容量变大以及存取效率的考量，也出现了4K扇区，可以看作是磁道上的一小段圆弧

了解以上内容，我们知道硬盘读取速度由快到慢分别是： 
1. 同一柱面-磁头变换是电子切换
2. 同一磁道-机械轴不需要移动，速度相对较快
3. 不同磁道-目前来说最慢的部分，因为要移动机械轴，文件碎片读取速度慢就是因为散落在不同磁道上，因而在操作系统上通常都会提供碎片整合的功能，以优化读取效率

如果确实需要到不同的磁道中读取，那么磁盘内部也会控制读取数据，争取以最小的开销读取到所有磁道的数据，相应的调度算法有FCFS、SSTF、SCAN、C-SCAN、LOOK、C-LOOK等

# 磁盘分区
## MBR
第一个扇区是用于存放引导程序和分区表的，其余扇区用于实际分区。

### 引导程序
引导程序是什么？

这里简单说一下CPU的执行原理，CPU并不能直接操作内存中的数据，这里说一下，这里的内存并非常规意义上的内存，所有的外部设备在CPU眼中都是内存，只是被分配了不同的地址区段，就是说CPU不能直接对外部设备中的数据进行运算和处理。

所以在说明CPU进行数据运算之前，我们需要了解CPU是怎么和外部设备进行交互的，这里假设我们只有一个保存数据的外部设备【多个设备需要考虑外中断的问题，这里不做介绍】，我们将它叫做内存设备。

CPU与内存交互是通过线路进行的，传输线路可以分为3种：
1. 数据线
2. 地址线
3. 控制线

通过这3类线路CPU就可以对内存设备执行读取或写入，然后拿到数据后，CPU会放到寄存器上，寄存器是CPU最核心的器件，寄存器也有很多种类和功能，有些寄存器是用来存放数据的，比如说AX、BX、CX、DX这几个，他们叫做通用寄存器。

然后数据有了，接下来就是执行指令，指令从哪来？同样是来自内存，这里介绍两个非常重要的寄存器CS和IP。

这两个寄存器都是表示指令地址的，比如说当前指向`0x20000`的内存地址，那么当前存放的`CS:IP`可以是`0x2000:0x0000`，CPU会读取该地址中的数据并将其视作指令执行。

这里就涉及到一个很有意思的点，计算机是怎么判断内存中的数据是指令还是数据？又是如何决定它是作为数据还是指令执行的？

举个例子，假设内存中存放的数据是这样的：
```
B8 //20000
```
内存中的数据是这样的，我们可以将其当作数据`B8`读取，也可以作为汇编指令`mov ax`使用，那么何时是数据，何时是指令呢？

关键在于是用哪个寄存器存放的，如果是`AX`、`BX`这类通用寄存器，那么就是数据，如果是`CS:IP`这类就是作为指令执行。

接下来说下`CS:IP`，其实这涉及到8086CPU的一个地址转换方法，目前的32位和64系统已经不再使用了。

首先8086CPU是16位系统，为方便处理运算，指令地址和数据在寄存器中是统一的，这同时限制了内存大小，简单来说就是CPU都是处理的16位数据，地址也属于数据的一部分，所以地址数据也是以16位存放的，但是实际上8086CPU系统的地址最大可以支持到20位，它是怎么做到的？

它是通过偏移法实现，这里的公式就是`段地址*16 + 偏移地址 = 物理地址`，不只是代码地址，数据地址，栈地址相关的寄存器都是使用的这种方式，通过段地址和便宜地址转换得到物理地址，进而读取数据。

好，到这一步基本就差不多了，另外额外提一句，所有电子设备的基本控制必然都是通过`BIOS`实现的，`CPU`也是如此，它有一个基本的控制程序，比如说默认从`0x000000`开始执行，进行一些必要的检查之后，会跳转到某个地址，这个地址就是我们引导程序的位置。

这是一个很有意思的设计，不只是用在引导程序上面，实际上程序的中断处理也是使用相同的设计，所以想要让用户自己控制启动，只要提供一个程序入口地址就行了，我们在对应地址放上对应的程序，之后的指令执行可以完全交给对应程序处理。

### 引导程序

## GPT