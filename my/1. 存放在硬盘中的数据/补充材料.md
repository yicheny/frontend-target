[TOC]

# 引导程序
引导程序是什么？

这里简单说一下CPU的执行原理，CPU并不能直接操作内存中的数据，这里说一下，这里的内存并非常规意义上的内存，所有的外部设备在CPU眼中都是内存，只是被分配了不同的地址区段，就是说CPU不能直接对外部设备中的数据进行运算和处理。

所以在说明CPU进行数据运算之前，我们需要了解CPU是怎么和外部设备进行交互的，这里假设我们只有一个保存数据的外部设备【多个设备需要考虑外中断的问题，这里不做介绍】，我们将它叫做内存设备。

CPU与内存交互是通过线路进行的，传输线路可以分为3种：
1. 数据线
2. 地址线
3. 控制线

通过这3类线路CPU就可以对内存设备执行读取或写入，然后拿到数据后，CPU会放到寄存器上，寄存器是CPU最核心的器件，寄存器也有很多种类和功能，有些寄存器是用来存放数据的，比如说AX、BX、CX、DX这几个，他们叫做通用寄存器。

然后数据有了，接下来就是执行指令，指令从哪来？同样是来自内存，这里介绍两个非常重要的寄存器CS和IP。

这两个寄存器都是表示指令地址的，比如说当前指向`0x20000`的内存地址，那么当前存放的`CS:IP`可以是`0x2000:0x0000`，CPU会读取该地址中的数据并将其视作指令执行。

这里就涉及到一个很有意思的点，计算机是怎么判断内存中的数据是指令还是数据？又是如何决定它是作为数据还是指令执行的？

举个例子，假设内存中存放的数据是这样的：
```
B8 //20000
```
内存中的数据是这样的，我们可以将其当作数据`B8`读取，也可以作为汇编指令`mov ax`使用，那么何时是数据，何时是指令呢？

关键在于是用哪个寄存器存放的，如果是`AX`、`BX`这类通用寄存器，那么就是数据，如果是`CS:IP`这类就是作为指令执行。

接下来说下`CS:IP`，其实这涉及到8086CPU的一个地址转换方法，目前的32位和64系统已经不再使用了。

首先8086CPU是16位系统，为方便处理运算，指令地址和数据在寄存器中是统一的，这同时限制了内存大小，简单来说就是CPU都是处理的16位数据，地址也属于数据的一部分，所以地址数据也是以16位存放的，但是实际上8086CPU系统的地址最大可以支持到20位，它是怎么做到的？

它是通过偏移法实现，这里的公式就是`段地址*16 + 偏移地址 = 物理地址`，不只是代码地址，数据地址，栈地址相关的寄存器都是使用的这种方式，通过段地址和便宜地址转换得到物理地址，进而读取数据。

CPU执行指令核心就是这4个字：**取址执行**

好，到这一步基本就差不多了，另外额外提一句，所有电子设备的基本控制必然都是通过`BIOS`实现的，`CPU`也是如此，它有一个基本的控制程序，比如说默认从`0x000000`开始执行，进行一些必要的检查之后，会跳转到某个地址，这个地址就是我们引导程序的位置。

这是一个很有意思的设计，不只是用在引导程序上面，实际上程序的中断处理也是使用相同的设计，所以想要让用户自己控制启动，只要提供一个程序入口地址就行了，我们在对应地址放上对应的程序，之后的指令执行可以完全交给对应程序处理。

简单来说就是，BIOS执行一些基本的比如设备连接检查的指令，然后跳转到某个指定地址执行指令，这个地址存放的程序就是引导程序。